{% extends "base.html" %}

{% block title %}Reader - Comic Server{% endblock %}

{% block extra_head %}
<style>
    body { overflow: hidden; background: #000; }

    [x-cloak] { display: none !important; }

    /* Layout */
    .reader-container {
        position: fixed; inset: 0;
        background: #000;
        display: flex; flex-direction: column;
        z-index: 100;
    }

    /* Toolbar */
    .reader-toolbar {
        background: rgba(0, 0, 0, 0.85);
        backdrop-filter: blur(10px);
        padding: 0.75rem 1rem;
        display: flex; justify-content: space-between; align-items: center;
        border-bottom: 1px solid rgba(255,255,255,0.1);
        z-index: 50;
        transition: transform 0.3s;
    }
    .reader-toolbar.hidden { transform: translateY(-100%); }

    /* Content Area */
    .reader-content {
        flex: 1; display: flex; align-items: center; justify-content: center;
        overflow: hidden; position: relative;
    }

    /* The Page Image */
    .reader-page {
        max-width: 100%; max-height: 100%;
        object-fit: contain;
        user-select: none;
    }

    /* Invisible Nav Zones */
    .nav-zone {
        position: absolute; top: 0; bottom: 0; width: 20%; z-index: 20;
        cursor: pointer;
    }
    .nav-zone.left { left: 0; }
    .nav-zone.right { right: 0; }
    .nav-zone:hover { background: linear-gradient(to right, rgba(255,255,255,0.05), transparent); }
    .nav-zone.right:hover { background: linear-gradient(to left, rgba(255,255,255,0.05), transparent); }

    /* Bottom Controls */
    .reader-controls {
        position: absolute; bottom: 2rem; left: 50%; transform: translateX(-50%);
        background: rgba(0, 0, 0, 0.9);
        backdrop-filter: blur(10px);
        padding: 0.75rem 1.5rem; border-radius: 9999px;
        display: flex; align-items: center; gap: 1rem;
        opacity: 0; transition: opacity 0.3s, transform 0.3s;
        z-index: 50; border: 1px solid rgba(255,255,255,0.1);
    }

    /* The Invisible Trigger Zone at the bottom */
    .hover-zone {
        position: absolute; bottom: 0; left: 0; right: 0;
        height: 15vh; /* Active in bottom 15% of screen or adjust to 20vh; if still seeing slight flicker */
        z-index: 40;
        background: transparent;
    }

    /* Base state for controls/scrubber: Hidden by default */
    .reader-controls, .scrubber-wrapper {
        opacity: 0;
        pointer-events: none;
        transition: opacity 0.3s, transform 0.3s;
    }

    /* Utility class to show them via Alpine */
    .controls-visible {
        opacity: 1 !important;
        pointer-events: auto !important;
    }

    /* Settings Panel */
    .settings-panel {
        position: absolute; top: 4rem; right: 1rem;
        background: rgba(20, 20, 20, 0.95);
        backdrop-filter: blur(10px);
        border: 1px solid rgba(255,255,255,0.1);
        border-radius: 0.5rem;
        padding: 1rem;
        width: 250px;
        z-index: 60;
        color: white;
    }

    .range-slider {
        width: 100%; height: 4px; background: #4b5563;
        border-radius: 2px; outline: none; -webkit-appearance: none;
    }
    .range-slider::-webkit-slider-thumb {
        -webkit-appearance: none; width: 16px; height: 16px;
        background: #3b82f6; border-radius: 50%; cursor: pointer;
    }


    /* SCRUBBER STYLES */
    .scrubber-wrapper {
        position: absolute; bottom: 5.5rem; /* Sit above the control buttons */
        left: 50%; transform: translateX(-50%);
        width: 90%; max-width: 600px;
        height: 20px; /* Hit area height */
        display: flex; align-items: center;
        z-index: 55;
        opacity: 0; transition: opacity 0.3s;
        pointer-events: none; /* Ignore clicks when hidden */
    }

    /* The Range Input Reset */
    input[type=range].scrubber {
        -webkit-appearance: none; width: 100%; background: transparent; cursor: pointer;
    }
    input[type=range].scrubber:focus { outline: none; }

    /* The Track (Chrome/Safari) */
    input[type=range].scrubber::-webkit-slider-runnable-track {
        width: 100%; height: 4px; cursor: pointer;
        background: rgba(255,255,255,0.3); border-radius: 2px;
        transition: height 0.2s, background 0.2s;
    }
    .scrubber-wrapper:hover input[type=range].scrubber::-webkit-slider-runnable-track {
        height: 6px; background: rgba(255,255,255,0.5);
    }

    /* The Thumb (Handle) */
    input[type=range].scrubber::-webkit-slider-thumb {
        height: 12px; width: 12px; border-radius: 50%;
        background: #3b82f6; cursor: pointer;
        -webkit-appearance: none;
        margin-top: -4px; /* Center on track */
        box-shadow: 0 0 10px rgba(0,0,0,0.5);
        transition: transform 0.2s;
    }
    .scrubber-wrapper:hover input[type=range].scrubber::-webkit-slider-thumb {
        transform: scale(1.5);
    }

    /* Tooltip for Page Number */
    .scrubber-tooltip {
        position: absolute; bottom: 25px;
        background: #3b82f6; color: white;
        padding: 2px 6px; border-radius: 4px;
        font-size: 0.75rem; font-weight: bold;
        pointer-events: none;
        transform: translateX(-50%);
        white-space: nowrap;
    }


</style>
{% endblock %}

{% block content %}

<div class="reader-container" x-data="reader()" tabindex="0" x-on:keydown.window="handleKey($event)">

    <div class="reader-toolbar">

        <!-- Left side close button + Comic information -->
        <div class="flex items-center space-x-4 max-w-[50%]">

            <button x-on:click="exitReader()" class="text-gray-400 hover:text-white px-2 py-1 rounded hover:bg-white/10 transition-colors">
                <span class="mr-1">‚úï</span> Close
            </button>
            <div class="flex flex-col overflow-hidden">
                <span class="font-bold text-white truncate" x-text="`${meta.series_name} #${meta.number}`"></span>

                <div class="flex items-center gap-2 text-xs truncate">

                    <span class="text-xs text-gray-400 truncate" x-text="meta.title" x-bind:title="meta.title"></span>
                    <template x-if="meta.context_total > 1">
                        <span class="text-blue-400 font-medium bg-blue-900/30 px-1.5 rounded border border-blue-500/30"
                              x-text="`${getContextLabel(meta.context_type)} / ${meta.context_label}: ${meta.context_position}/${meta.context_total}`">
                        </span>
                    </template>

                </div>

            </div>
        </div>

        <!-- Right side icons -->
        <div class="flex items-center space-x-2">

            <button x-on:click="toggleUiLock()" class="p-2 rounded hover:bg-white/10 transition-colors"
                    :class="uiLocked ? 'text-blue-400' : 'text-gray-300'"
                    title="Toggle UI Lock (h)">
                <svg x-show="uiLocked" xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" />
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M2.458 12C3.732 7.943 7.523 5 12 5c4.478 0 8.268 2.943 9.542 7-1.274 4.057-5.064 7-9.542 7-4.477 0-8.268-2.943-9.542-7z" />
                </svg>
                <svg x-show="!uiLocked" xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13.875 18.825A10.05 10.05 0 0112 19c-4.478 0-8.268-2.943-9.543-7a9.97 9.97 0 011.563-3.029m5.858.908a3 3 0 114.243 4.243M9.878 9.878l4.242 4.242M9.88 9.88l-3.29-3.29m7.532 7.532l3.29 3.29M3 3l3.59 3.59m0 0A9.953 9.953 0 0112 5c4.478 0 8.268 2.943 9.543 7a10.025 10.025 0 01-4.132 5.411m0 0L21 21" />
                </svg>
            </button>


            <button x-on:click.stop="showSettings = !showSettings" class="p-2 text-gray-300 hover:text-white rounded hover:bg-white/10" :class="{'text-blue-400': showSettings}" title="Settings">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 6V4m0 2a2 2 0 100 4m0-4a2 2 0 110 4m-6 8a2 2 0 100-4m0 4a2 2 0 110-4m0 4v2m0-6V4m6 6v10m6-2a2 2 0 100-4m0 4a2 2 0 110-4m0 4v2m0-6V4" />
                </svg>
            </button>

            <button x-on:click="toggleFullscreen()" class="p-2 text-gray-300 hover:text-white rounded hover:bg-white/10" title="Toggle Fullscreen (f)">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 8V4m0 0h4M4 4l5 5m11-1V4m0 0h-4m4 0l-5 5M4 16v4m0 0h4m-4 0l5-5m11 5l-5-5m5 5v-4m0 4h-4" />
                </svg>
            </button>
        </div>
    </div>

    <div class="settings-panel shadow-2xl" x-show="showSettings" x-cloak
        x-transition:enter="transition ease-out duration-200"
        x-transition:enter-start="opacity-0 transform scale-95"
        x-transition:enter-end="opacity-100 transform scale-100"
        x-transition:leave="transition ease-in duration-100"
        x-transition:leave-start="opacity-100 transform scale-100"
        x-transition:leave-end="opacity-0 transform scale-95" x-on:click.away="showSettings = false">

        <h3 class="text-sm font-bold text-gray-400 uppercase mb-4">Layout</h3>

        <div class="space-y-4 mb-6">
            <div class="flex items-center justify-between">
                <label class="text-sm">Double Page (d)</label>
                <button
                    x-on:click="viewMode = (viewMode === 'single' ? 'double' : 'single')"
                    class="relative inline-flex h-6 w-11 flex-shrink-0 cursor-pointer rounded-full border-2 border-transparent transition-colors duration-200 ease-in-out focus:outline-none"
                    :class="viewMode === 'double' ? 'bg-blue-600' : 'bg-gray-700'"
                >
                    <span class="pointer-events-none inline-block h-5 w-5 transform rounded-full bg-white shadow ring-0 transition duration-200 ease-in-out"
                          :class="viewMode === 'double' ? 'translate-x-5' : 'translate-x-0'"></span>
                </button>
            </div>

           <div class="flex items-center justify-between pl-4 border-l-2 border-gray-700 transition-all"
                 x-show="viewMode === 'double'"
                 x-transition:enter="transition ease-out duration-200"
                 x-transition:enter-start="opacity-0 -translate-y-2"
                 x-transition:enter-end="opacity-100 translate-y-0">

                <label class="text-sm text-gray-300">Book Shadow</label>
                <input type="checkbox" x-model="showSpineShadow" class="rounded bg-gray-700 border-gray-600 text-blue-500 focus:ring-0">
            </div>

            <div class="flex items-center justify-between pl-4 border-l-2 border-gray-700 transition-all"
                 x-show="viewMode === 'double'"
                 x-transition:enter="transition ease-out duration-200"
                 x-transition:enter-start="opacity-0 -translate-y-2"
                 x-transition:enter-end="opacity-100 translate-y-0">

                <label class="text-sm text-gray-400">Cover Offset</label>
                <input type="checkbox" x-model="doublePageOffset" class="rounded bg-gray-700 border-gray-600 text-blue-500 focus:ring-0">
            </div>


            <div class="flex items-center justify-between">
                <label class="text-sm">Manga Mode (m)</label>
                <button
                    x-on:click="toggleMangaMode()"
                    class="relative inline-flex h-6 w-11 flex-shrink-0 cursor-pointer rounded-full border-2 border-transparent transition-colors duration-200 ease-in-out focus:outline-none"
                    :class="readDirection === 'rtl' ? 'bg-blue-600' : 'bg-gray-700'"
                >
                    <span class="pointer-events-none inline-block h-5 w-5 transform rounded-full bg-white shadow ring-0 transition duration-200 ease-in-out"
                          :class="readDirection === 'rtl' ? 'translate-x-5' : 'translate-x-0'"></span>
                </button>
            </div>

        </div>

        <h3 class="text-sm font-bold text-gray-400 uppercase mb-4">Display Options</h3>

        <div class="space-y-4">

            <div class="flex items-center justify-between">
                <label class="text-sm" title="Reduces bandwidth by converting images to WebP">
                    Reduce Data Usage
                </label>
                <input type="checkbox" x-model="filters.transcode" class="rounded bg-gray-700 border-gray-600 text-blue-500 focus:ring-0" x-on:change="$el.blur()">
            </div>

            <div class="flex items-center justify-between">
                <label class="text-sm">Black & White</label>
                <input type="checkbox" x-model="filters.grayscale" class="rounded bg-gray-700 border-gray-600 text-blue-500 focus:ring-0" x-on:change="$el.blur()">
            </div>

            <div class="flex items-center justify-between">
                <label class="text-sm">Sharpen (Scan)</label>
                <input type="checkbox" x-model="filters.sharpen" class="rounded bg-gray-700 border-gray-600 text-blue-500 focus:ring-0" x-on:change="$el.blur()">
            </div>

            <div>
                <div class="flex justify-between text-xs text-gray-400 mb-1">
                    <span>Brightness</span>
                    <span x-text="`${filters.brightness}%`"></span>
                </div>
                <input type="range" min="50" max="150" x-model="filters.brightness" class="range-slider" x-on:change="$el.blur()">
            </div>

            <div>
                <div class="flex justify-between text-xs text-gray-400 mb-1">
                    <span>Contrast</span>
                    <span x-text="`${filters.contrast}%`"></span>
                </div>
                <input type="range" min="50" max="150" x-model="filters.contrast" class="range-slider" x-on:change="$el.blur()">
            </div>

            <div class="border-t border-gray-700 pt-3">
                 <button @click="resetFilters()" class="text-xs text-red-400 hover:text-red-300 w-full text-center">Reset to Defaults</button>
            </div>
        </div>
    </div>

    <div class="hover-zone"
         x-on:mouseenter="isHoveringZone = true"
         x-on:mouseleave="isHoveringZone = false">
    </div>

    <div class="reader-content">

        <div class="nav-zone left" x-on:click="handleZoneClick('left')"></div>
        <div class="nav-zone right" x-on:click="handleZoneClick('right')"></div>

        <div class="flex items-center justify-center h-full w-full"
                     :class="{
                        'flex-row': readDirection === 'ltr',
                        'flex-row-reverse': readDirection === 'rtl',
                        'gap-0': true
                     }">


            <template x-for="(page, idx) in pagesToDisplay" :key="page.index">
                    <img
                        :src="getPageUrl(page.index)"
                        :class="imageClasses"
                        class="reader-page"
                        :class="{
                            /* LEFT SIDE OF SCREEN: Align to Right (Spine) */
                            'object-right': viewMode === 'double' && pagesToDisplay.length > 1 && (
                                (readDirection === 'ltr' && idx === 0) ||
                                (readDirection === 'rtl' && idx === 1)
                            ),

                            /* RIGHT SIDE OF SCREEN: Align to Left (Spine) */
                            'object-left': viewMode === 'double' && pagesToDisplay.length > 1 && (
                                (readDirection === 'ltr' && idx === 1) ||
                                (readDirection === 'rtl' && idx === 0)
                            )
                        }"
                        :style="imageStyles"
                        alt="Page"
                    >
            </template>


            {# Comic spine emulation #}
            <div class="absolute inset-y-0 left-1/2 w-24 -translate-x-1/2 pointer-events-none z-20"
                 x-show="viewMode === 'double' && pagesToDisplay.length === 2 && showSpineShadow"
                 x-transition:enter="transition-opacity duration-200"
                 x-transition:enter-start="opacity-0"
                 x-transition:enter-end="opacity-100"
                 style="background: linear-gradient(90deg,
                        transparent 0%,
                        rgba(0,0,0,0.05) 30%,
                        rgba(0,0,0,0.4) 50%,
                        rgba(0,0,0,0.05) 70%,
                        transparent 100%);">
            </div>


        </div>

        <div class="scrubber-wrapper" :class="{'controls-visible': shouldShowUI}" x-show="meta.page_count > 0">

            <div class="scrubber-tooltip"
                 x-show="isScrubbing || isHoveringScrubber"
                 :style="`left: ${(scrubberValue / (meta.page_count - 1)) * 100}%`"
                 x-text="parseInt(scrubberValue) + 1">
            </div>

            <input type="range"
                   class="scrubber"
                   min="0"
                   :max="meta.page_count - 1"
                   x-model="scrubberValue"
                   x-on:mouseenter="isHoveringScrubber = true"
                   x-on:mouseleave="isHoveringScrubber = false"
                   x-on:mousedown="isScrubbing = true"
                   x-on:touchstart="isScrubbing = true"
                   x-on:change="finishScrub()"
                   x-on:input="updateScrubberUI()"
            >
        </div>


        <div class="reader-controls" :class="{'controls-visible': shouldShowUI}"
                                    x-on:mouseenter="isHoveringBar = true" x-on:mouseleave="isHoveringBar = false"
        >
            <button
                @click="goToBook(meta.prev_comic_id)"
                :disabled="!meta.prev_comic_id"
                class="text-gray-400 hover:text-white disabled:opacity-30 disabled:cursor-not-allowed"
                title="Previous Issue ([)"
            >‚èÆ</button>

            <button x-on:click="prevPage()" class="text-white hover:text-blue-400 text-2xl px-2">‚óÄ</button>

            <div class="flex items-center space-x-2 text-sm font-mono text-gray-300 mx-2">
                <span x-text="currentPage + 1" class="text-white font-bold"></span>
                <span class="text-gray-500">/</span>
                <span x-text="meta.page_count"></span>
            </div>

            <button x-on:click="nextPage()" class="text-white hover:text-blue-400 text-2xl px-2">‚ñ∂</button>

            <button
                @click="goToBook(meta.next_comic_id)"
                :disabled="!meta.next_comic_id"
                class="text-gray-400 hover:text-white disabled:opacity-30 disabled:cursor-not-allowed"
                title="Next Issue (])"
            >‚è≠</button>

            <div class="w-px h-6 bg-gray-700 mx-2"></div>

             <select x-model="fitMode" class="bg-transparent text-xs text-gray-400 focus:outline-none cursor-pointer" x-on:change="$el.blur()">
                <option value="contain">Fit Screen</option>
                <option value="width">Fit Width</option>
                <option value="height">Fit Height</option>
            </select>
        </div>
    </div>

<div x-show="showGoto" x-cloak
         class="fixed inset-0 z-[70] flex items-center justify-center bg-black/80 backdrop-blur-sm"
         x-transition:enter="transition ease-out duration-200"
         x-transition:enter-start="opacity-0"
         x-transition:enter-end="opacity-100"
         x-transition:leave="transition ease-in duration-100"
         x-transition:leave-start="opacity-100"
         x-transition:leave-end="opacity-0"
         @click.self="closeGoto()">

        <div class="bg-gray-900 border border-gray-700 p-6 rounded-lg shadow-2xl w-80 text-center transform transition-all"
             x-transition:enter="scale-95"
             x-transition:enter-end="scale-100">

            <h3 class="text-white font-bold text-lg mb-4">Go to Page</h3>

            <div class="flex items-center justify-center space-x-2 mb-6">
                <input x-ref="gotoInput"
                       type="number"
                       x-model="gotoInputValue"
                       @keydown.enter="submitGoto()"
                       @keydown.escape="closeGoto()"
                       min="1"
                       :max="meta.page_count"
                       class="bg-gray-800 text-white text-2xl font-bold w-24 text-center border-b-2 border-blue-500 focus:outline-none focus:border-blue-400 py-2 rounded-t"
                >
                <span class="text-gray-500 text-xl">/ <span x-text="meta.page_count"></span></span>
            </div>

            <div class="flex justify-between space-x-3">
                <button @click="closeGoto()" class="flex-1 px-4 py-2 text-gray-400 hover:text-white hover:bg-white/10 rounded transition-colors">
                    Cancel
                </button>
                <button @click="submitGoto()" class="flex-1 px-4 py-2 bg-blue-600 hover:bg-blue-500 text-white font-bold rounded transition-colors">
                    Go
                </button>
            </div>
        </div>
    </div>

</div>

<script>
function reader() {
    return {
        // --- Core State ---
        comicId: {{ comic_id }},
        currentPage: 0,
        meta: { page_count: 0, next_comic_id: null, prev_comic_id: null },

        // --- Settings ---
        showSettings: false,
        fitMode: 'contain',
        viewMode: 'single', // 'single', 'double'
        readDirection: 'ltr', // 'ltr' (Western), 'rtl' (Manga)
        doublePageOffset: true, // If true, Page 0 is separate (Cover mode)
        showSpineShadow: false, // For use in double page mode

        // --- UI State ---
        showGoto: false,
        gotoInputValue: 1,
        scrubberValue: 0,
        isScrubbing: false,  // True while dragging
        isHoveringScrubber: false,
        uiLocked: false,  // If true, UI is always on
        isHoveringZone: false,  // If true, mouse is at the bottom
        isHoveringBar: false,  // The actual button bar
        isIncognito: false,
        contextType: null,
        contextId: null,

        // --- Image Cache & Metadata ---
        // Stores data about pages we've sniffed (e.g., { 0: { isLandscape: false, loaded: true } })
        pageMeta: {},

        // Filter State
        filters: {
            transcode: false,
            grayscale: false,
            sharpen: false,
            brightness: 100,
            contrast: 100
        },

        init() {

            // Load settings from local storage
            this.viewMode = localStorage.getItem('reader_viewMode') || 'single';
            this.readDirection = localStorage.getItem('reader_readDirection') || 'ltr';
            this.fitMode = localStorage.getItem('reader_fitMode') || 'contain';
            this.doublePageOffset = JSON.parse(localStorage.getItem('reader_doublePageOffset') ?? 'true');
            this.showSpineShadow = JSON.parse(localStorage.getItem('reader_showSpineShadow') ?? 'true');

            // Check for incognito flag immediately
            const params = new URLSearchParams(window.location.search);
            this.isIncognito = params.get('incognito') === 'true';
            this.contextType = params.get('context_type');
            this.contextId = params.get('context_id');

            if (this.isIncognito) {
                window.comicServer.showToast("üëì Incognito Mode: Progress will not be saved.");
            }

            this.loadInitData();

            // Sync Slider -> Page (Watch for external page changes)
            this.$watch('currentPage', (val) => {
                if (!this.isScrubbing) {
                    this.scrubberValue = val;
                }

                // TRIGGER PRELOAD
                this.preloadContext();
            });

            // Restore filters from localStorage (MERGE strategy)
            const savedFilters = localStorage.getItem('readerFilters');
            if(savedFilters) {
               const parsed = JSON.parse(savedFilters);
                // Spread the parsed values ON TOP of the current defaults.
                // This ensures 'transcode' (and future keys) survive if missing from storage.
                this.filters = { ...this.filters, ...parsed };
            }

            // Force a save immediately to "heal" the local storage with the new key
            localStorage.setItem('readerFilters', JSON.stringify(this.filters));

            // Persist filters on change
            this.$watch('filters', val => localStorage.setItem('readerFilters', JSON.stringify(val)));
            this.$watch('viewMode', val => localStorage.setItem('reader_viewMode', val));
            this.$watch('readDirection', val => localStorage.setItem('reader_readDirection', val));
            this.$watch('fitMode', val => localStorage.setItem('reader_fitMode', val));
            this.$watch('doublePageOffset', val => localStorage.setItem('reader_doublePageOffset', val));
            this.$watch('showSpineShadow', val => localStorage.setItem('reader_showSpineShadow', val));
        },

        async loadInitData() {
            try {

                const params = new URLSearchParams();
                if(this.contextType) params.append('context_type', this.contextType);
                if(this.contextId) params.append('context_id', this.contextId);

                // Fetch new Init endpoint from comics API
                const res = await fetch(window.url(`/api/reader/${this.comicId}/read-init?${params.toString()}`));

                if (!res.ok) {
                    window.showToast('Failed to init reader', 'error')
                    throw new Error('Failed to init reader');
                }
                this.meta = await res.json();

                // If Incognito, DO NOT load previous progress. Start fresh.
                if (!this.isIncognito) {
                    // Check for saved progress
                    const progRes = await fetch(window.url(`/api/progress/${this.comicId}`));
                    const prog = await progRes.json();

                    if (prog.has_progress && !prog.completed) {
                        this.currentPage = prog.current_page;
                    }
                }

                // Initial Preload Kickoff
                this.preloadContext();

            } catch (e) { console.error(e); }
        },

        // ------------------------------
        // --- Preloading Engine ---
        // ------------------------------
        preloadContext() {
            // Determine how far to look ahead
            const lookahead = this.viewMode === 'double' ? 4 : 2;

            for (let i = 1; i <= lookahead; i++) {
                const targetPage = this.currentPage + i;
                if (targetPage < this.meta.page_count) {
                    this.preloadImage(targetPage);
                }
            }
        },

        preloadImage(index) {

            // Avoid re-fetching if we already know about this page
            if (this.pageMeta[index] && this.pageMeta[index].loaded) return;

            const img = new Image();
            img.src = this.getPageUrl(index);

            img.onload = () => {
                // SNIFF DIMENSIONS for "Smart Spreads"
                const isLandscape = img.width > img.height;

                // Reactive update to pageMeta
                this.pageMeta[index] = {
                    loaded: true,
                    isLandscape: isLandscape,
                    width: img.width,
                    height: img.height
                };
            };
        },
        // ------------------------------


        // Helper to construct URL
        getPageUrl(index) {
            if (index === undefined || index < 0 || index >= this.meta.page_count) return '';

            // Points to reader.py endpoint
            let url = window.url(`/api/reader/${this.comicId}/page/${index}`);

            // Append Server-Side Filters
            const params = new URLSearchParams();
            if (this.filters.transcode) params.append('webp', 'true');
            if (this.filters.sharpen) params.append('sharpen', 'true');
            if (this.filters.grayscale) params.append('grayscale', 'true');

            // CACHE BUSTER: Add a key based on the filter state
            // Create a stable cache key based on filter state
            // We only want to bust cache if FILTERS change, not time.
            const filterKey = `${this.filters.transcode}-${this.filters.sharpen}-${this.filters.grayscale}-${this.filters.brightness}-${this.filters.contrast}`;
            params.append('v', filterKey);

            const queryString = params.toString();
            return queryString ? `${url}?${queryString}` : url;
        },


        // Helper for CSS classes
        get imageClasses() {
            // 1. Check if we are in "Smart Spread" mode
            // (Double View selected, but only 1 page is being returned)
            const isSmartSpread = this.viewMode === 'double' && this.pagesToDisplay.length === 1;

            if (this.viewMode === 'double' && !isSmartSpread) {
                // Standard Double Page: Two images side-by-side.
                // Cap them at 50vw so they fit.
                // REMOVED mx-auto: This fixes the gap.
                // Use 'w-1/2' (50% width) instead of 'max-w-[50vw]'.
                // This reserves the screen space instantly, preventing the "fill" animation.
                // Also add 'h-screen' to ensure the vertical bounding box is stable.
                return 'w-1/2 h-screen object-contain';
            } else {
                // Single View OR Smart Spread (Wide image acting as single)
                return 'w-full h-screen object-contain';
            }
        },

        // Defines strictly if a page MUST stand alone
        isPageSolo(index) {
            // A. Cover Offset Rule (Page 0 is always solo if enabled)
            if (this.doublePageOffset && index === 0) return true;

            // B. Smart Landscape Rule (Wide images are always solo)
            if (this.pageMeta[index] && this.pageMeta[index].isLandscape) return true;

            return false;
        },


        get imageStyles() {
            // Combine Fit Mode and CSS Filters
            let styles = {};

            // Fit Mode
            //if (this.fitMode === 'contain') { styles.maxWidth = '100%'; styles.maxHeight = '100%'; styles.width='auto'; styles.height='auto'; }
            //else if (this.fitMode === 'width') { styles.width = '100%'; styles.height = 'auto'; styles.maxWidth = 'none'; styles.maxHeight = 'none'; }
            //else if (this.fitMode === 'height') { styles.height = '100%'; styles.width = 'auto'; styles.maxWidth = 'none'; styles.maxHeight = 'none'; }

            // Fit Mode Logic
            if (this.fitMode === 'contain') {
                styles.height = '100vh';
                styles.width = 'auto';
            } else if (this.fitMode === 'width') {
                styles.width = this.viewMode === 'double' ? '50vw' : '100vw';
                styles.height = 'auto';
            } else if (this.fitMode === 'height') {
                styles.height = '100vh';
                styles.width = 'auto';
            }

            // Filters (Client Side)
            let filterString = `brightness(${this.filters.brightness}%) contrast(${this.filters.contrast}%)`;

            styles.filter = filterString;
            return styles;
        },

        nextPage() {
            // Calculate how many pages we are CURRENTLY showing.
            // If showing [1], move 1. If showing [1,2], move 2.
            const step = this.pagesToDisplay.length;

            if (this.currentPage + step < this.meta.page_count) {
                this.currentPage += step;
                this.updateProgress();
            } else if (this.meta.next_comic_id) {
                window.comicServer.showToast("End of Book. Press ] for next issue.");
            }
        },

        prevPage() {

            if (this.viewMode === 'single') {
                if (this.currentPage > 0) this.currentPage--;
                return;
            }

            // Double Mode Look-Back
            // We need to determine if the PREVIOUS view was a pair or a solo.

            // Target candidate: The page immediately before current
            const prev1 = this.currentPage - 1;
            if (prev1 < 0) return; // Already at start

            // Scenario A: The previous page is a Solo (Spread or Cover)
            // View was [prev1] -> Step back 1
            if (this.isPageSolo(prev1)) {
                this.currentPage -= 1;
                this.updateProgress();
                return;
            }

            // Scenario B: The page BEFORE that (prev2) was a Solo.
            // This implies prev1 was an "orphan" single page.
            // View was [prev1] -> Step back 1
            const prev2 = this.currentPage - 2;
            if (prev2 >= 0 && this.isPageSolo(prev2)) {
                this.currentPage -= 1;
                this.updateProgress();
                return;
            }

            // Scenario C: Start of book edge case
            // If we are at Page 1 (No offset), prev1=0.
            // If 0 is NOT solo, it pairs with 1? No, we are at 1.
            // This means 0 was unpaired or we wouldn't be at 1.
            // Actually, if we are at 1, and 0 is NOT solo, we should probably jump to 0.
            // But usually standard pairs are 0-1, 2-3. You can't be at 1 unless 0 was solo.
            // So this case might be unreachable in ideal flow, but safe to handle.
            if (prev2 < 0) {
                // We are at 1. Jump to 0.
                this.currentPage = 0;
                this.updateProgress();
                return;
            }

            // Scenario D: Standard Pair
            // Neither prev1 nor prev2 forced a break.
            // View was [prev2, prev1] -> Step back 2
            this.currentPage -= 2;
            this.updateProgress();
        },

        goToBook(id) {
            if(!id) return;

            // 3. Persist Context when changing books
            let url = `/reader/${id}`;
            const params = new URLSearchParams();

            // Pass the context forward
            if(this.contextType) params.append('context_type', this.contextType);
            if(this.contextId) params.append('context_id', this.contextId);

            // Preserve Incognito if set
            if(this.isIncognito) params.append('incognito', 'true');

            const qs = params.toString();
            if(qs) url += `?${qs}`;

            window.location.href = url;
        },

        exitReader() {

            // Smart Exit Logic based on Context
            if (this.contextType === 'reading_list' && this.contextId) {
                // Go back to the specific reading list
                window.location.href = `/reading-lists/${this.contextId}`;
            }
            else if (this.contextType === 'collection' && this.contextId) {
                // Go back to the specific collection
                window.location.href = `/collections/${this.contextId}`;
            }
            else if (this.contextType === 'pull_list' && this.contextId) {
                // Go back to the specific pull list
                window.location.href = `/pull-lists/${this.contextId}`;
            }
            else if (this.contextType === 'series' && this.contextId) {
                window.location.href = `/series/${this.contextId}`;
            }
            else if (this.contextType === 'volume' && this.contextId) {
                // Determine if we need to switch tabs?
                // Usually just going back to the page is enough, Alpine init will handle state.
                window.location.href = `/volumes/${this.contextId}`;
            }
            else {
                // Default: Go back to the comic detail page
                window.location.href = `/comics/${this.comicId}`;
            }
        },

        resetFilters() {
            this.filters = { transcode: false, grayscale: false, sharpen: false, brightness: 100, contrast: 100 };
        },

        async updateProgress() {

            // Block updates if incognito
            if (this.isIncognito) { return; }

            // Debounce or fire-and-forget
            fetch(`/api/progress/${this.comicId}`, {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({ current_page: this.currentPage, total_pages: this.meta.page_count })
            });

            // If on last page, mark complete
            if (this.currentPage === this.meta.page_count - 1) {
                 fetch(`/api/progress/${this.comicId}/mark-read`, { method: 'POST' });
            }
        },

        toggleFullscreen() {
            if (!document.fullscreenElement) document.documentElement.requestFullscreen();
            else document.exitFullscreen();
        },

        // Centralized Key Handler
        handleKey(e) {

            // If the user is typing in the GOTO box, we only want to listen for Escape.
            // We ignore other shortcuts so they can type numbers properly.
            if (this.showGoto) {
                if (e.key === 'Escape') this.closeGoto();
                return;
            }

            // Ignore shortcuts if user is typing in a text box (future proofing)
            if (['INPUT', 'TEXTAREA'].includes(e.target.tagName) && e.target.type === 'text') return;

            // Ignore browser shortcuts (Ctrl/Cmd + R, etc)
            if (e.ctrlKey || e.metaKey || e.altKey) return;

            switch(e.key) {
                case 'ArrowRight':
                case ' ': // Spacebar
                    e.preventDefault(); // Stop scrolling
                    this.nextPage();
                    break;

                case 'ArrowLeft':
                    this.prevPage();
                    break;

                case 'f':
                case 'F':
                    this.toggleFullscreen();
                    break;

                case ']':
                    this.goToBook(this.meta.next_comic_id);
                    break;

                case '[':
                    this.goToBook(this.meta.prev_comic_id);
                    break;

                case 'd': // Toggle Double
                case 'D':
                    this.viewMode = this.viewMode === 'single' ? 'double' : 'single';
                    window.comicServer.showToast(this.viewMode === 'double' ? "Double Page Mode" : "Single Page Mode");
                    break;

                case 'g':
                case 'G':
                    e.preventDefault(); // Prevent accidental scrolling
                    this.openGoto();
                    break;

                case 'h':
                case 'H':
                    this.toggleUiLock();
                    break;

                case 'm': // Toggle Manga
                case 'M':
                    this.toggleMangaMode();
                    break;

                case 'Escape':
                    // Priority Logic for ESC
                    if (this.showGoto) {
                        this.closeGoto();
                        return;
                    }

                    // If Settings panel is open, close it first
                    if (this.showSettings) {
                        this.showSettings = false;
                        return;
                    }

                    // 2. If we are just exiting fullscreen (browser handled this),
                    // we might want to stay on the page.
                    // However, we can't easily detect "Just Exited Fullscreen" in a synchronous key event.
                    // Usually, the browser swallows the keydown for exiting fullscreen entirely.

                    // 3. Exit Reader
                    this.exitReader();
                    break;
            }
        },

        openGoto() {
            this.showGoto = true;
            this.gotoInputValue = this.currentPage + 1; // Convert 0-index to human readable

            // Wait for x-show to render, then focus the input
            this.$nextTick(() => {
                this.$refs.gotoInput.focus();
                this.$refs.gotoInput.select(); // Select text so they can overwrite immediately
            });
        },

        closeGoto() {
            this.showGoto = false;
            // Return focus to main container so arrow keys work again immediately
            this.$el.focus();
        },

        submitGoto() {
            let page = parseInt(this.gotoInputValue);

            // Validation
            if (isNaN(page)) return;
            if (page < 1) page = 1;
            if (page > this.meta.page_count) page = this.meta.page_count;

            // Update State (Convert back to 0-index)
            this.currentPage = page - 1;
            this.updateProgress();
            this.closeGoto();
        },

        updateScrubberUI() {
            // This fires rapidly while dragging.
            // We enable 'isScrubbing' here to pause the $watch listener above.
            this.isScrubbing = true;
        },

        finishScrub() {
            // Fires when user releases the mouse/touch
            this.isScrubbing = false;

            // Convert string input to int
            const targetPage = parseInt(this.scrubberValue);

            if (targetPage !== this.currentPage) {
                this.currentPage = targetPage;
                this.updateProgress();
            }
        },

        // Computed property for visibility
        get shouldShowUI() {

            return this.uiLocked
                || this.isHoveringZone
                || this.showSettings
                || this.showGoto
                || this.isScrubbing
                // Keep visible if touching the elements themselves
                || this.isHoveringScrubber
                || this.isHoveringBar;
         },

        toggleUiLock() {
            this.uiLocked = !this.uiLocked;
            window.comicServer.showToast(this.uiLocked ? "UI Pinned" : "UI Auto-Hide");
        },

        getContextLabel(context_type) {
            if(context_type === "pull_list") return "Pull List";
            if(context_type === "reading_list") return "Reading List";
            if(context_type === "collection") return "Collection";
            if(context_type === "series") return "Series";
            return "Volume";
        },

        // CORE LOGIC: Which pages to render?
        get pagesToDisplay() {

            // 1. Single Mode
            if (this.viewMode === 'single') {
                return [{ index: this.currentPage }];
            }

            // Standard Double Mode Logic
            const p1 = this.currentPage;
            const p2 = this.currentPage + 1;

            // Rule 1: Is P1 a solo page? (Cover or Spread)
            if (this.isPageSolo(p1)) {
                return [{ index: p1 }];
            }

            // Rule 2: End of book check
            if (p2 >= this.meta.page_count) {
                return [{ index: p1 }];
            }

            // Rule 3: Is P2 a solo page? (The "Smart Spread" check)
            // CRITICAL FIX: If P2 is a spread, P1 cannot pair with it. P1 must be alone.
            if (this.isPageSolo(p2)) {
                return [{ index: p1 }];
            }

            // Rule 4: Standard Pair
            return [{ index: p1 }, { index: p2 }];
        },


        handleZoneClick(zone) {
            // Context Aware Clicking
            // If LTR: Left = Prev, Right = Next
            // If RTL: Left = Next, Right = Prev

            if (this.readDirection === 'rtl') {
                if (zone === 'left') this.nextPage();
                else this.prevPage();
            } else {
                if (zone === 'left') this.prevPage();
                else this.nextPage();
            }
        },

        toggleMangaMode() {
            this.readDirection = this.readDirection === 'ltr' ? 'rtl' : 'ltr';
            window.comicServer.showToast(this.readDirection === 'rtl' ? "Manga Mode (RTL)" : "Western Mode (LTR)");
        },

    }
}
</script>
{% endblock %}