{% extends "base.html" %}

{% block title %}Reader - Comic Server{% endblock %}

{% block extra_head %}
<style>
    body { overflow: hidden; background: #000; }

    [x-cloak] { display: none !important; }

    /* Layout */
    .reader-container {
        position: fixed; inset: 0;
        background: #000;
        display: flex; flex-direction: column;
        z-index: 100;
    }

    /* Toolbar */
    .reader-toolbar {
        background: rgba(0, 0, 0, 0.85);
        backdrop-filter: blur(10px);
        padding: 0.75rem 1rem;
        display: flex; justify-content: space-between; align-items: center;
        border-bottom: 1px solid rgba(255,255,255,0.1);
        z-index: 50;
        transition: transform 0.3s;
    }
    .reader-toolbar.hidden { transform: translateY(-100%); }

    /* Content Area */
    .reader-content {
        flex: 1; display: flex; align-items: center; justify-content: center;
        overflow: hidden; position: relative;
    }

    /* The Page Image */
    .reader-page {
        max-width: 100%; max-height: 100%;
        object-fit: contain;
        user-select: none;
        transition: transform 0.1s; /* Smooth zoom if added later */
    }

    /* Invisible Nav Zones */
    .nav-zone {
        position: absolute; top: 0; bottom: 0; width: 20%; z-index: 20;
        cursor: pointer;
    }
    .nav-zone.left { left: 0; }
    .nav-zone.right { right: 0; }
    .nav-zone:hover { background: linear-gradient(to right, rgba(255,255,255,0.05), transparent); }
    .nav-zone.right:hover { background: linear-gradient(to left, rgba(255,255,255,0.05), transparent); }

    /* Bottom Controls */
    .reader-controls {
        position: absolute; bottom: 2rem; left: 50%; transform: translateX(-50%);
        background: rgba(0, 0, 0, 0.9);
        backdrop-filter: blur(10px);
        padding: 0.75rem 1.5rem; border-radius: 9999px;
        display: flex; align-items: center; gap: 1rem;
        opacity: 0; transition: opacity 0.3s, transform 0.3s;
        z-index: 50; border: 1px solid rgba(255,255,255,0.1);
    }

    /* The Invisible Trigger Zone at the bottom */
    .hover-zone {
        position: absolute; bottom: 0; left: 0; right: 0;
        height: 15vh; /* Active in bottom 15% of screen or adjust to 20vh; if still seeing slight flicker */
        z-index: 40;
        background: transparent;
    }

    /* Base state for controls/scrubber: Hidden by default */
    .reader-controls, .scrubber-wrapper {
        opacity: 0;
        pointer-events: none;
        transition: opacity 0.3s, transform 0.3s;
    }

    /* Utility class to show them via Alpine */
    .controls-visible {
        opacity: 1 !important;
        pointer-events: auto !important;
    }

    /* Settings Panel */
    .settings-panel {
        position: absolute; top: 4rem; right: 1rem;
        background: rgba(20, 20, 20, 0.95);
        backdrop-filter: blur(10px);
        border: 1px solid rgba(255,255,255,0.1);
        border-radius: 0.5rem;
        padding: 1rem;
        width: 250px;
        z-index: 60;
        color: white;
    }

    .range-slider {
        width: 100%; height: 4px; background: #4b5563;
        border-radius: 2px; outline: none; -webkit-appearance: none;
    }
    .range-slider::-webkit-slider-thumb {
        -webkit-appearance: none; width: 16px; height: 16px;
        background: #3b82f6; border-radius: 50%; cursor: pointer;
    }


    /* SCRUBBER STYLES */
    .scrubber-wrapper {
        position: absolute; bottom: 5.5rem; /* Sit above the control buttons */
        left: 50%; transform: translateX(-50%);
        width: 90%; max-width: 600px;
        height: 20px; /* Hit area height */
        display: flex; align-items: center;
        z-index: 55;
        opacity: 0; transition: opacity 0.3s;
        pointer-events: none; /* Ignore clicks when hidden */
    }

    /* The Range Input Reset */
    input[type=range].scrubber {
        -webkit-appearance: none; width: 100%; background: transparent; cursor: pointer;
    }
    input[type=range].scrubber:focus { outline: none; }

    /* The Track (Chrome/Safari) */
    input[type=range].scrubber::-webkit-slider-runnable-track {
        width: 100%; height: 4px; cursor: pointer;
        background: rgba(255,255,255,0.3); border-radius: 2px;
        transition: height 0.2s, background 0.2s;
    }
    .scrubber-wrapper:hover input[type=range].scrubber::-webkit-slider-runnable-track {
        height: 6px; background: rgba(255,255,255,0.5);
    }

    /* The Thumb (Handle) */
    input[type=range].scrubber::-webkit-slider-thumb {
        height: 12px; width: 12px; border-radius: 50%;
        background: #3b82f6; cursor: pointer;
        -webkit-appearance: none;
        margin-top: -4px; /* Center on track */
        box-shadow: 0 0 10px rgba(0,0,0,0.5);
        transition: transform 0.2s;
    }
    .scrubber-wrapper:hover input[type=range].scrubber::-webkit-slider-thumb {
        transform: scale(1.5);
    }

    /* Tooltip for Page Number */
    .scrubber-tooltip {
        position: absolute; bottom: 25px;
        background: #3b82f6; color: white;
        padding: 2px 6px; border-radius: 4px;
        font-size: 0.75rem; font-weight: bold;
        pointer-events: none;
        transform: translateX(-50%);
        white-space: nowrap;
    }


</style>
{% endblock %}

{% block content %}

<div class="reader-container" x-data="reader()" tabindex="0" x-on:keydown.window="handleKey($event)">

    <div class="reader-toolbar">

        <!-- Left side close button + Comic information -->
        <div class="flex items-center space-x-4 max-w-[50%]">

            <button x-on:click="exitReader()" class="text-gray-400 hover:text-white px-2 py-1 rounded hover:bg-white/10 transition-colors">
                <span class="mr-1">✕</span> Close
            </button>
            <div class="flex flex-col overflow-hidden">
                <span class="font-bold text-white truncate" x-text="`${meta.series_name} #${meta.number}`"></span>
                <span class="text-xs text-gray-400 truncate" x-text="meta.title"></span>
            </div>
        </div>

        <!-- Right side icons -->
        <div class="flex items-center space-x-2">

            <button x-on:click="toggleUiLock()" class="p-2 rounded hover:bg-white/10 transition-colors"
                    :class="uiLocked ? 'text-blue-400' : 'text-gray-300'"
                    title="Toggle UI Lock (h)">
                <svg x-show="uiLocked" xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" />
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M2.458 12C3.732 7.943 7.523 5 12 5c4.478 0 8.268 2.943 9.542 7-1.274 4.057-5.064 7-9.542 7-4.477 0-8.268-2.943-9.542-7z" />
                </svg>
                <svg x-show="!uiLocked" xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13.875 18.825A10.05 10.05 0 0112 19c-4.478 0-8.268-2.943-9.543-7a9.97 9.97 0 011.563-3.029m5.858.908a3 3 0 114.243 4.243M9.878 9.878l4.242 4.242M9.88 9.88l-3.29-3.29m7.532 7.532l3.29 3.29M3 3l3.59 3.59m0 0A9.953 9.953 0 0112 5c4.478 0 8.268 2.943 9.543 7a10.025 10.025 0 01-4.132 5.411m0 0L21 21" />
                </svg>
            </button>


            <button x-on:click.stop="showSettings = !showSettings" class="p-2 text-gray-300 hover:text-white rounded hover:bg-white/10" :class="{'text-blue-400': showSettings}" title="Settings">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 6V4m0 2a2 2 0 100 4m0-4a2 2 0 110 4m-6 8a2 2 0 100-4m0 4a2 2 0 110-4m0 4v2m0-6V4m6 6v10m6-2a2 2 0 100-4m0 4a2 2 0 110-4m0 4v2m0-6V4" />
                </svg>
            </button>

            <button x-on:click="toggleFullscreen()" class="p-2 text-gray-300 hover:text-white rounded hover:bg-white/10" title="Toggle Fullscreen (f)">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 8V4m0 0h4M4 4l5 5m11-1V4m0 0h-4m4 0l-5 5M4 16v4m0 0h4m-4 0l5-5m11 5l-5-5m5 5v-4m0 4h-4" />
                </svg>
            </button>
        </div>
    </div>

    <div class="settings-panel shadow-2xl" x-show="showSettings" x-cloak
        x-transition:enter="transition ease-out duration-200"
        x-transition:enter-start="opacity-0 transform scale-95"
        x-transition:enter-end="opacity-100 transform scale-100"
        x-transition:leave="transition ease-in duration-100"
        x-transition:leave-start="opacity-100 transform scale-100"
        x-transition:leave-end="opacity-0 transform scale-95" x-on:click.away="showSettings = false">
        <h3 class="text-sm font-bold text-gray-400 uppercase mb-4">Display Options</h3>

        <div class="space-y-4">
            <div class="flex items-center justify-between">
                <label class="text-sm">Black & White</label>
                <input type="checkbox" x-model="filters.grayscale" class="rounded bg-gray-700 border-gray-600 text-blue-500 focus:ring-0" x-on:change="$el.blur()">
            </div>

            <div class="flex items-center justify-between">
                <label class="text-sm">Sharpen (Scan)</label>
                <input type="checkbox" x-model="filters.sharpen" class="rounded bg-gray-700 border-gray-600 text-blue-500 focus:ring-0" x-on:change="$el.blur()">
            </div>

            <div>
                <div class="flex justify-between text-xs text-gray-400 mb-1">
                    <span>Brightness</span>
                    <span x-text="`${filters.brightness}%`"></span>
                </div>
                <input type="range" min="50" max="150" x-model="filters.brightness" class="range-slider" x-on:change="$el.blur()">
            </div>

            <div>
                <div class="flex justify-between text-xs text-gray-400 mb-1">
                    <span>Contrast</span>
                    <span x-text="`${filters.contrast}%`"></span>
                </div>
                <input type="range" min="50" max="150" x-model="filters.contrast" class="range-slider" x-on:change="$el.blur()">
            </div>

            <div class="border-t border-gray-700 pt-3">
                 <button @click="resetFilters()" class="text-xs text-red-400 hover:text-red-300 w-full text-center">Reset to Defaults</button>
            </div>
        </div>
    </div>

    <div class="hover-zone"
         x-on:mouseenter="isHoveringZone = true"
         x-on:mouseleave="isHoveringZone = false">
    </div>

    <div class="reader-content">
        <div class="nav-zone left" x-on:click="prevPage()"></div>
        <div class="nav-zone right" x-on:click="nextPage()"></div>

        <img
            id="current-page"
            class="reader-page"
            :src="currentPageUrl"
            :style="imageStyles"
            alt="Page"
        >

        <div class="scrubber-wrapper" :class="{'controls-visible': shouldShowUI}" x-show="meta.page_count > 0">

            <div class="scrubber-tooltip"
                 x-show="isScrubbing || isHoveringScrubber"
                 :style="`left: ${(scrubberValue / (meta.page_count - 1)) * 100}%`"
                 x-text="parseInt(scrubberValue) + 1">
            </div>

            <input type="range"
                   class="scrubber"
                   min="0"
                   :max="meta.page_count - 1"
                   x-model="scrubberValue"
                   x-on:mouseenter="isHoveringScrubber = true"
                   x-on:mouseleave="isHoveringScrubber = false"
                   x-on:mousedown="isScrubbing = true"
                   x-on:touchstart="isScrubbing = true"
                   x-on:change="finishScrub()"
                   x-on:input="updateScrubberUI()"
            >
        </div>


        <div class="reader-controls" :class="{'controls-visible': shouldShowUI}"
                                    x-on:mouseenter="isHoveringBar = true" x-on:mouseleave="isHoveringBar = false"
        >
            <button
                @click="goToBook(meta.prev_comic_id)"
                :disabled="!meta.prev_comic_id"
                class="text-gray-400 hover:text-white disabled:opacity-30 disabled:cursor-not-allowed"
                title="Previous Issue ([)"
            >⏮</button>

            <button x-on:click="prevPage()" class="text-white hover:text-blue-400 text-2xl px-2">◀</button>

            <div class="flex items-center space-x-2 text-sm font-mono text-gray-300 mx-2">
                <span x-text="currentPage + 1" class="text-white font-bold"></span>
                <span class="text-gray-500">/</span>
                <span x-text="meta.page_count"></span>
            </div>

            <button x-on:click="nextPage()" class="text-white hover:text-blue-400 text-2xl px-2">▶</button>

            <button
                @click="goToBook(meta.next_comic_id)"
                :disabled="!meta.next_comic_id"
                class="text-gray-400 hover:text-white disabled:opacity-30 disabled:cursor-not-allowed"
                title="Next Issue (])"
            >⏭</button>

            <div class="w-px h-6 bg-gray-700 mx-2"></div>

             <select x-model="fitMode" class="bg-transparent text-xs text-gray-300 focus:outline-none cursor-pointer" x-on:change="$el.blur()">
                <option value="contain">Fit Screen</option>
                <option value="width">Fit Width</option>
                <option value="height">Fit Height</option>
            </select>
        </div>
    </div>

<div x-show="showGoto" x-cloak
         class="fixed inset-0 z-[70] flex items-center justify-center bg-black/80 backdrop-blur-sm"
         x-transition:enter="transition ease-out duration-200"
         x-transition:enter-start="opacity-0"
         x-transition:enter-end="opacity-100"
         x-transition:leave="transition ease-in duration-100"
         x-transition:leave-start="opacity-100"
         x-transition:leave-end="opacity-0"
         @click.self="closeGoto()">

        <div class="bg-gray-900 border border-gray-700 p-6 rounded-lg shadow-2xl w-80 text-center transform transition-all"
             x-transition:enter="scale-95"
             x-transition:enter-end="scale-100">

            <h3 class="text-white font-bold text-lg mb-4">Go to Page</h3>

            <div class="flex items-center justify-center space-x-2 mb-6">
                <input x-ref="gotoInput"
                       type="number"
                       x-model="gotoInputValue"
                       @keydown.enter="submitGoto()"
                       @keydown.escape="closeGoto()"
                       min="1"
                       :max="meta.page_count"
                       class="bg-gray-800 text-white text-2xl font-bold w-24 text-center border-b-2 border-blue-500 focus:outline-none focus:border-blue-400 py-2 rounded-t"
                >
                <span class="text-gray-500 text-xl">/ <span x-text="meta.page_count"></span></span>
            </div>

            <div class="flex justify-between space-x-3">
                <button @click="closeGoto()" class="flex-1 px-4 py-2 text-gray-400 hover:text-white hover:bg-white/10 rounded transition-colors">
                    Cancel
                </button>
                <button @click="submitGoto()" class="flex-1 px-4 py-2 bg-blue-600 hover:bg-blue-500 text-white font-bold rounded transition-colors">
                    Go
                </button>
            </div>
        </div>
    </div>

</div>

<script>
function reader() {
    return {
        comicId: {{ comic_id }},
        currentPage: 0,
        meta: { page_count: 0, next_comic_id: null, prev_comic_id: null },
        showSettings: false,
        fitMode: 'contain',
        showGoto: false,
        gotoInputValue: 1,
        scrubberValue: 0,
        isScrubbing: false,  // True while dragging
        isHoveringScrubber: false,
        uiLocked: false,  // If true, UI is always on
        isHoveringZone: false,  // If true, mouse is at the bottom
        isHoveringBar: false,  // The actual button bar

        // Filter State
        filters: {
            grayscale: false,
            sharpen: false,
            brightness: 100,
            contrast: 100
        },

        init() {
            this.loadInitData();

            // Sync Slider -> Page (Watch for external page changes)
            this.$watch('currentPage', (val) => {
                if (!this.isScrubbing) {
                    this.scrubberValue = val;
                }
            });

            // Restore filters from localStorage
            const savedFilters = localStorage.getItem('readerFilters');
            if(savedFilters) this.filters = JSON.parse(savedFilters);

            // Persist filters on change
            this.$watch('filters', val => localStorage.setItem('readerFilters', JSON.stringify(val)));
        },

        async loadInitData() {
            try {
                // Fetch new Init endpoint from comics API
                const res = await fetch(`/api/comics/${this.comicId}/read-init`);
                if (!res.ok) throw new Error("Failed to init reader");
                this.meta = await res.json();

                // Check for saved progress
                const progRes = await fetch(`/api/progress/${this.comicId}`);
                const prog = await progRes.json();

                if (prog.has_progress && !prog.completed) {
                    this.currentPage = prog.current_page;
                }
            } catch (e) { console.error(e); }
        },

        get currentPageUrl() {
            if (this.meta.page_count === 0) return '';

            // Points to comics.py endpoint
            let url = `/api/comics/${this.comicId}/page/${this.currentPage}`;

            // Append Server-Side Filters
            const params = new URLSearchParams();
            if (this.filters.sharpen) params.append('sharpen', 'true');
            if (this.filters.grayscale) params.append('grayscale', 'true');

            // CACHE BUSTER: Add a timestamp based on the filter state
            // This ensures a unique URL when settings change, forcing a re-fetch
            // We use the values of the filters to create a semi-stable key,
            // or just Date.now() if you want to force it every time (easiest for debugging).
            params.append('_t', Date.now());

            const queryString = params.toString();

            return queryString ? `${url}?${queryString}` : url;
        },

        get imageStyles() {
            // Combine Fit Mode and CSS Filters
            let styles = {};

            // Fit Mode
            if (this.fitMode === 'contain') { styles.maxWidth = '100%'; styles.maxHeight = '100%'; styles.width='auto'; styles.height='auto'; }
            else if (this.fitMode === 'width') { styles.width = '100%'; styles.height = 'auto'; styles.maxWidth = 'none'; styles.maxHeight = 'none'; }
            else if (this.fitMode === 'height') { styles.height = '100%'; styles.width = 'auto'; styles.maxWidth = 'none'; styles.maxHeight = 'none'; }

            // Filters (Client Side)
            let filterString = `brightness(${this.filters.brightness}%) contrast(${this.filters.contrast}%)`;

            styles.filter = filterString;
            return styles;
        },

        nextPage() {
            if (this.currentPage < this.meta.page_count - 1) {
                this.currentPage++;
                this.updateProgress();
            } else if (this.meta.next_comic_id) {
                // Optional: Auto-advance to next book
                // if(confirm("Next Issue?")) this.goToBook(this.meta.next_comic_id);
                this.showToast("End of Book. Press ] for next issue.");
            }
        },

        prevPage() {
            if (this.currentPage > 0) {
                this.currentPage--;
                this.updateProgress();
            }
        },

        goToBook(id) {
            if(id) window.location.href = `/reader/${id}`;
        },

        exitReader() {
            window.location.href = `/comics/${this.comicId}`;
        },

        resetFilters() {
            this.filters = { grayscale: false, sharpen: false, brightness: 100, contrast: 100 };
        },

        async updateProgress() {
            // Debounce or fire-and-forget
            fetch(`/api/progress/${this.comicId}`, {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({ current_page: this.currentPage, total_pages: this.meta.page_count })
            });

            // If on last page, mark complete
            if (this.currentPage === this.meta.page_count - 1) {
                 fetch(`/api/progress/${this.comicId}/mark-read`, { method: 'POST' });
            }
        },

        toggleFullscreen() {
            if (!document.fullscreenElement) document.documentElement.requestFullscreen();
            else document.exitFullscreen();
        },

        showToast(msg) {
            // Simple toast implementation
            const div = document.createElement('div');
            div.className = 'fixed bottom-20 left-1/2 transform -translate-x-1/2 bg-gray-800 text-white px-4 py-2 rounded shadow-lg z-50';
            div.innerText = msg;
            document.body.appendChild(div);
            setTimeout(() => div.remove(), 2000);
        },

        // Centralized Key Handler
        handleKey(e) {

            // If the user is typing in the GOTO box, we only want to listen for Escape.
            // We ignore other shortcuts so they can type numbers properly.
            if (this.showGoto) {
                if (e.key === 'Escape') this.closeGoto();
                return;
            }

            // Ignore shortcuts if user is typing in a text box (future proofing)
            if (['INPUT', 'TEXTAREA'].includes(e.target.tagName) && e.target.type === 'text') return;

            // Ignore browser shortcuts (Ctrl/Cmd + R, etc)
            if (e.ctrlKey || e.metaKey || e.altKey) return;

            switch(e.key) {
                case 'ArrowRight':
                case ' ': // Spacebar
                    e.preventDefault(); // Stop scrolling
                    this.nextPage();
                    break;

                case 'ArrowLeft':
                    this.prevPage();
                    break;

                case 'f':
                case 'F':
                    this.toggleFullscreen();
                    break;

                case ']':
                    this.goToBook(this.meta.next_comic_id);
                    break;

                case '[':
                    this.goToBook(this.meta.prev_comic_id);
                    break;

                case 'g':
                case 'G':
                    e.preventDefault(); // Prevent accidental scrolling
                    this.openGoto();
                    break;

                case 'h':
                case 'H':
                    this.toggleUiLock();
                    break;

                case 'Escape':
                    // Priority Logic for ESC
                    if (this.showGoto) {
                        this.closeGoto();
                        return;
                    }

                    // If Settings panel is open, close it first
                    if (this.showSettings) {
                        this.showSettings = false;
                        return;
                    }

                    // 2. If we are just exiting fullscreen (browser handled this),
                    // we might want to stay on the page.
                    // However, we can't easily detect "Just Exited Fullscreen" in a synchronous key event.
                    // Usually, the browser swallows the keydown for exiting fullscreen entirely.

                    // 3. Exit Reader
                    this.exitReader();
                    break;
            }
        },

        openGoto() {
            this.showGoto = true;
            this.gotoInputValue = this.currentPage + 1; // Convert 0-index to human readable

            // Wait for x-show to render, then focus the input
            this.$nextTick(() => {
                this.$refs.gotoInput.focus();
                this.$refs.gotoInput.select(); // Select text so they can overwrite immediately
            });
        },

        closeGoto() {
            this.showGoto = false;
            // Return focus to main container so arrow keys work again immediately
            this.$el.focus();
        },

        submitGoto() {
            let page = parseInt(this.gotoInputValue);

            // Validation
            if (isNaN(page)) return;
            if (page < 1) page = 1;
            if (page > this.meta.page_count) page = this.meta.page_count;

            // Update State (Convert back to 0-index)
            this.currentPage = page - 1;
            this.updateProgress();
            this.closeGoto();
        },

        updateScrubberUI() {
            // This fires rapidly while dragging.
            // We enable 'isScrubbing' here to pause the $watch listener above.
            this.isScrubbing = true;
        },

        finishScrub() {
            // Fires when user releases the mouse/touch
            this.isScrubbing = false;

            // Convert string input to int
            const targetPage = parseInt(this.scrubberValue);

            if (targetPage !== this.currentPage) {
                this.currentPage = targetPage;
                this.updateProgress();
            }
        },

        // Computed property for visibility
        get shouldShowUI() {

            return this.uiLocked
                || this.isHoveringZone
                || this.showSettings
                || this.showGoto
                || this.isScrubbing
                // Keep visible if touching the elements themselves
                || this.isHoveringScrubber
                || this.isHoveringBar;
         },

        toggleUiLock() {
            this.uiLocked = !this.uiLocked;
            this.showToast(this.uiLocked ? "UI Pinned" : "UI Auto-Hide");
        },

    }
}
</script>
{% endblock %}