{% extends "base.html" %}

{% block title %}Advanced Search - Comic Server{% endblock %}

{% block content %}
<div class="max-w-6xl mx-auto" x-data="searchBuilder()">

    <div class="flex justify-between items-center mb-6">
        <h1 class="text-3xl font-bold text-white">Advanced Search</h1>

        <div x-show="contextLibraryId" class="mb-6 flex items-center gap-2" x-cloak>
            <div class="bg-blue-900/50 text-blue-200 px-3 py-1 rounded-full border border-blue-800 flex items-center text-sm">
                <span class="mr-2">ðŸ“‚</span>
                <span>Searching in: <b x-text="contextLibraryName || 'Library #' + contextLibraryId"></b></span>

                <button x-on:click="contextLibraryId = null; contextLibraryName = null; performSearch()" class="ml-2 hover:text-white" title="Search Everything">
                    âœ•
                </button>
            </div>
        </div>
        <div class="flex space-x-3" x-data="{ showLoadMenu: false }">
            <div class="relative">
                <button
                    x-on:click="showLoadMenu = !showLoadMenu; if(showLoadMenu) loadSavedList()"
                    x-on:click.away="showLoadMenu = false"
                    class="px-4 py-2 bg-gray-700 hover:bg-gray-600 text-gray-200 rounded-lg flex items-center gap-2 transition-colors"
                >
                    <span>ðŸ“‚ Load</span>
                    <span class="text-xs">â–¼</span>
                </button>

                <div
                    x-show="showLoadMenu"
                    class="absolute right-0 mt-2 w-64 bg-gray-800 border border-gray-600 rounded-lg shadow-xl z-50 overflow-hidden"
                    style="display: none;"
                    x-transition
                >
                    <div x-show="savedSearches.length === 0 && smartLists.length === 0" class="p-4 text-gray-500 text-sm text-center">
                        No saved configurations.
                    </div>

                    <template x-if="savedSearches.length > 0">
                        <div>
                            <div class="px-3 py-1 text-[10px] uppercase font-bold text-gray-500 bg-gray-900/50">Saved Searches</div>
                            <template x-for="search in savedSearches" :key="'saved-' + search.id">
                                <div class="flex items-center justify-between p-2 hover:bg-gray-700 border-b border-gray-700/50 group cursor-pointer" x-on:click="applySearch(search); showLoadMenu = false">
                                    <div class="flex items-center gap-2 flex-1 min-w-0">
                                        <span class="text-gray-400">ðŸ“‚</span>
                                        <span class="text-sm text-blue-300 hover:text-white truncate" x-text="search.name"></span>
                                    </div>
                                    <button x-on:click.stop="deleteSearch(search.id)" class="text-gray-600 hover:text-red-400 px-2 opacity-0 group-hover:opacity-100 transition-opacity">âœ•</button>
                                </div>
                            </template>
                        </div>
                    </template>

                    <template x-if="smartLists.length > 0">
                        <div>
                            <div class="px-3 py-1 text-[10px] uppercase font-bold text-indigo-500 bg-gray-900/50 border-t border-gray-700">Smart Filters</div>
                            <template x-for="list in smartLists" :key="'smart-' + list.id">
                                <div class="flex items-center justify-between p-2 hover:bg-gray-700 border-b border-gray-700/50 group cursor-pointer" x-on:click="applySearch(list); showLoadMenu = false">
                                    <div class="flex items-center gap-2 flex-1 min-w-0">
                                        <span class="text-indigo-400">âš¡</span>
                                        <span class="text-sm text-indigo-200 hover:text-white truncate" x-text="list.name"></span>
                                    </div>
                                    </div>
                            </template>
                        </div>
                    </template>

                </div>
            </div>

            <button
                x-on:click="openSaveModal()"
                class="px-4 py-2 bg-blue-600 hover:bg-blue-500 text-white rounded-lg flex items-center gap-2 transition-colors"
            >
                <span>ðŸ’¾ Save</span>
            </button>
        </div>
    </div>

    <div class="bg-gray-800 rounded-xl p-6 border border-gray-700 shadow-xl">

        <div class="flex items-center space-x-4 mb-6 border-b border-gray-700 pb-4">
            <span class="text-gray-400">Match</span>
            <select x-model="match" class="bg-gray-700 text-white rounded px-3 py-1 border border-gray-600 focus:ring-2 focus:ring-blue-500 outline-none">
                <option value="all">All Rules (AND)</option>
                <option value="any">Any Rule (OR)</option>
            </select>
            <span class="text-gray-400">of the following:</span>
        </div>

        <div class="space-y-4">
            <template x-for="(rule, index) in rules" :key="rule.id">
                <div class="flex flex-col md:flex-row gap-3 items-start md:items-center bg-gray-900/50 p-3 rounded-lg border border-gray-700/50">

                    <select x-model="rule.field" x-on:change="resetRule(rule)" class="w-full md:w-48 bg-gray-700 text-white rounded px-3 py-2 border border-gray-600 outline-none">
                        <optgroup label="Metadata">
                            <option value="series">Series Name</option>
                            <option value="title">Issue Title</option>
                            <option value="publisher">Publisher</option>
                            <option value="year">Release Year</option>
                            <option value="format">Format</option>
                            <option value="imprint">Imprint</option>
                            <option value="summary">Summary</option>
                            <option value="web">Web/Wiki Link</option>
                            <option value="rating">Community Rating</option>
                            <option value="age_rating">Age Rating</option>
                            <option value="language">Language (ISO)</option>
                        </optgroup>
                        <optgroup label="Creators">
                            <option value="writer">Writer</option>
                            <option value="penciller">Penciller</option>
                            <option value="inker">Inker</option>
                            <option value="colorist">Colorist</option>
                            <option value="editor">Editor</option>
                        </optgroup>
                        <optgroup label="Tags">
                            <option value="character">Character</option>
                            <option value="team">Team</option>
                            <option value="location">Location</option>
                            <option value="genre">Genre</option>
                        </optgroup>
                        <optgroup label="Organization">
                            <option value="library">Library</option>
                            <option value="collection">Collection</option>
                            <option value="reading_list">Reading List</option>
                            <option value="pull_list">Pull List</option>
                        </optgroup>
                    </select>

                    <select x-model="rule.operator" class="w-full md:w-40 bg-gray-700 text-white rounded px-3 py-2 border border-gray-600 outline-none">
                        <option value="equal">Equals</option>
                        <option value="not_equal">Not Equals</option>
                        <option value="contains">Contains (Any)</option>
                        <option value="does_not_contain">Does Not Contain</option>
                        <option value="must_contain">Must Contain (All)</option>
                        <option value="is_empty">Is Empty</option>
                        <option value="is_not_empty">Is Not Empty</option>
                    </select>

                    <div class="flex-1 w-full" x-show="!['is_empty', 'is_not_empty'].includes(rule.operator)">

                        <div x-show="['title', 'year', 'summary', 'web', 'rating'].includes(rule.field)">
                            <input type="text" x-on:keydown.enter="performSearch()" x-model="rule.value" class="w-full bg-gray-700 text-white rounded px-3 py-2 border border-gray-600 outline-none focus:border-blue-500">
                        </div>

                        <div x-show="!['title', 'year', 'summary', 'web', 'rating'].includes(rule.field)">
                            <div
                                x-data="tagInput(rule)"
                                class="relative w-full"
                            >
                                <div class="bg-gray-700 border border-gray-600 rounded p-1 flex flex-wrap gap-2 min-h-[42px]">
                                    <template x-for="(tag, i) in tags" :key="i">
                                        <span class="bg-blue-600 text-white text-sm px-2 py-0.5 rounded flex items-center">
                                            <span x-text="tag"></span>
                                            <button x-on:click="removeTag(i)" class="ml-1 hover:text-red-300 font-bold">Ã—</button>
                                        </span>
                                    </template>

                                    <input
                                        type="text"
                                        x-model="input"
                                        x-show="!(['equal', 'not_equal'].includes(rule.operator) && tags.length > 0)"
                                        @input.debounce.300ms="fetchSuggestions()"
                                        x-on:keydown.enter.prevent="addTag()"
                                        x-on:keydown.backspace="handleBackspace()"
                                        x-on:blur="addTag()"
                                        class="bg-transparent border-none focus:ring-0 text-white flex-1 min-w-[120px] outline-none h-8 px-1"
                                        placeholder="Type to find..."
                                    >
                                </div>

                                <div x-show="suggestions.length > 0" x-on:click.away="suggestions = []" class="absolute z-10 w-full bg-gray-700 border border-gray-600 rounded mt-1 shadow-lg max-h-60 overflow-y-auto">
                                    <template x-for="sugg in suggestions" :key="sugg">
                                        <div
                                            x-on:click="selectSuggestion(sugg)"
                                            x-on:mousedown.prevent
                                            class="px-3 py-2 hover:bg-blue-600 cursor-pointer text-white border-b border-gray-600 last:border-0"
                                            x-text="sugg"
                                        ></div>
                                    </template>
                                </div>
                            </div>
                        </div>

                    </div>

                    <button x-on:click="removeRule(index)" class="text-red-400 hover:text-red-300 p-2 hover:bg-red-900/30 rounded" title="Remove Rule">
                        âœ•
                    </button>
                </div>
            </template>
        </div>

        <div class="mt-4">
            <button x-on:click="addRule()" class="text-blue-400 hover:text-blue-300 font-bold flex items-center px-3 py-2 hover:bg-gray-700 rounded transition-colors">
                <span class="text-xl mr-2">+</span> Add Rule
            </button>
        </div>

        <div class="border-t border-gray-700 my-6"></div>

        <div class="flex flex-col md:flex-row justify-between items-center gap-4">
            <div class="flex items-center space-x-6">
                <div class="flex items-center space-x-2">
                    <span class="text-gray-400 text-sm">Sort By</span>
                    <select x-model="sortBy" class="bg-gray-700 text-white rounded px-2 py-1 text-sm border border-gray-600 outline-none">
                        <option value="created">Date Added</option>
                        <option value="updated">Date Updated</option>
                        <option value="year">Release Year</option>
                        <option value="series">Series Name</option>
                        <option value="title">Issue Title</option>
                        <option value="page_count">Page Count</option>
                        <option value="rating">Community Rating</option>
                    </select>
                </div>
                <div class="flex items-center space-x-2">
                    <span class="text-gray-400 text-sm">Limit</span>
                    <input type="number" x-model="limit" class="w-20 bg-gray-700 text-white rounded px-2 py-1 text-sm border border-gray-600 outline-none text-center">
                </div>
            </div>

            <button x-on:click="performSearch()" class="w-full md:w-auto bg-blue-600 hover:bg-blue-500 text-white font-bold py-2 px-8 rounded-lg shadow-lg flex items-center justify-center gap-2 transition-colors">
                <span x-show="loading" class="animate-spin">â†»</span>
                <span>Search Comics</span>
            </button>
        </div>
    </div>

    <div class="mt-8" x-show="hasSearched" style="display: none;">
        <h2 class="text-xl font-bold mb-4 flex items-center text-white">
            Results
            <span class="ml-3 text-sm font-normal text-gray-300 bg-gray-800 px-3 py-1 rounded-full border border-gray-700" x-text="`${totalResults} found`"></span>
        </h2>

        <div class="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-6 gap-4">
             <template x-for="comic in results" :key="comic.id">
                {% include "partials/comic_card.html" %}
             </template>
        </div>

        <div x-show="!loading && results.length === 0" class="text-center py-20 bg-gray-800/50 rounded-xl border border-dashed border-gray-700">
            <p class="text-gray-400 text-lg">No comics found matching your criteria.</p>
            <button x-on:click="rules=[{id:1, field:'series', operator:'contains', value:[]}]" class="mt-4 text-blue-400 hover:underline">Reset Filters</button>
        </div>
    </div>


<div x-show="saveModalOpen"
     class="fixed inset-0 bg-black/80 flex items-center justify-center z-50 backdrop-blur-sm"
     style="display: none;"
     x-transition.opacity>

    <div class="bg-gray-800 p-6 rounded-xl w-full max-w-md border border-gray-700 shadow-2xl"
         x-on:click.away="saveModalOpen = false">

        <h3 class="text-xl font-bold mb-1 text-white">Save Configuration</h3>
        <p class="text-sm text-gray-400 mb-6">Name your search filters to save them.</p>

        <div class="mb-6">
            <label class="block text-xs uppercase font-bold text-gray-500 mb-2">Name</label>
            <input
                type="text"
                x-model="newSearchName"
                placeholder="e.g. 'Alan Moore 80s'"
                class="w-full bg-gray-900 border border-gray-600 rounded-lg px-4 py-3 text-white focus:border-blue-500 focus:ring-1 focus:ring-blue-500 outline-none transition-colors"
                x-on:keydown.enter="saveSearch()"
            >
        </div>

        <div class="grid grid-cols-1 gap-3">
            <button x-on:click="saveSearch()"
                    class="w-full bg-gray-700 hover:bg-gray-600 text-gray-200 font-medium py-3 rounded-lg flex items-center justify-center gap-3 transition-colors group">
                <span class="text-xl group-hover:scale-110 transition-transform">ðŸ“‚</span>
                <div class="text-left">
                    <div class="text-sm font-bold">Save to Search Menu</div>
                    <div class="text-[10px] text-gray-400">Quick access from this page</div>
                </div>
            </button>

            <button x-on:click="saveAsSmartList()"
                    class="w-full bg-indigo-600 hover:bg-indigo-500 text-white font-medium py-3 rounded-lg flex items-center justify-center gap-3 transition-colors group shadow-lg shadow-indigo-900/20">
                <span class="text-xl group-hover:scale-110 transition-transform">âš¡</span>
                <div class="text-left">
                    <div class="text-sm font-bold"><span x-text="loadedListId === null ? 'Create' : 'Update'"></span> Smart List</div>
                    <div class="text-[10px] text-indigo-200">Auto-updating list on Dashboard</div>
                </div>
            </button>
        </div>

        <div class="mt-6 text-center">
            <button x-on:click="saveModalOpen = false" class="text-sm text-gray-500 hover:text-white transition-colors">
                Cancel
            </button>
        </div>
    </div>
</div>

</div>



<script>
document.addEventListener('alpine:init', () => {

    // 1. Tag Input Component (Reusable for each row)
    Alpine.data('tagInput', (rule) => ({
        input: '',
        tags: [], // Local array to hold badges
        suggestions: [],

        init() {

            // 1. Initial Population
            this.syncTagsFromRule();

            // 2. Watch for changes from parent (e.g. loading saved search)
            // We pass a function to $watch to observe the external 'rule' object
            this.$watch(() => rule.value, (newValue) => {
                this.syncTagsFromRule();
            });

            // If rule has value loaded from save, populate tags
            // Ensure we handle both single value (string/int) and array
            //if (rule.value) {
                //this.tags = Array.isArray(rule.value) ? rule.value : [rule.value];
            //}
        },

        syncTagsFromRule() {

            if (rule.value) {
                const newTags = Array.isArray(rule.value) ? rule.value : [rule.value];

                // Only update if different to avoid feedback loops
                // (Simple stringify check is sufficient for string arrays)
                if (JSON.stringify(newTags) !== JSON.stringify(this.tags)) {
                    this.tags = [...newTags]; // Create a copy
                }
            } else {
                this.tags = [];
            }
        },

        async fetchSuggestions() {
            if (this.input.length < 2) {
                this.suggestions = [];
                return;
            }
            try {
                // Call our API
                const res = await fetch(window.url(`/api/search/suggestions?field=${rule.field}&query=${this.input}`));
                this.suggestions = await res.json();
            } catch(e) { console.error(e); }
        },

        addTag() {
            if (this.input.trim()) {
                this.tags.push(this.input.trim());
                this.updateRuleValue();
                this.input = '';
                this.suggestions = [];
            }
        },

        selectSuggestion(val) {
            this.tags.push(val);
            this.updateRuleValue();
            this.input = '';
            this.suggestions = [];
        },

        removeTag(index) {
            this.tags.splice(index, 1);
            this.updateRuleValue();
        },

        handleBackspace() {
            if (this.input === '' && this.tags.length > 0) {
                this.tags.pop();
                this.updateRuleValue();
            }
        },

        updateRuleValue() {
            // Update the parent rule object
            // We use a spread copy to ensure reactivity triggers if needed
            rule.value = [...this.tags];
            //rule.value = this.tags;
        }
    }));

    // 2. Main Search Builder Logic
    Alpine.data('searchBuilder', () => ({
        rules: [
            { id: 1, field: 'series', operator: 'contains', value: [] }
        ],
        match: 'all',
        limit: 50,
        sortBy: 'created',
        sortOrder: 'desc',
        results: [],
        totalResults: 0,
        loading: false,
        hasSearched: false,
        nextId: 2,

        savedSearches: [],
        smartLists: [],
        saveModalOpen: false,
        newSearchName: '',
        loadedListId: null,

        contextLibraryId: null,
        contextLibraryName: null, // Optional, for display (requires fetching)

        async init() {
            await this.loadSavedList();
            this.checkUrlParams();
        },

        checkUrlParams() {

            const params = new URLSearchParams(window.location.search);
            let shouldSearch = false;

            // Strategy A: Load Complex Smart List by ID if present
            if (params.has('smart_list_id')) {
                const id = parseInt(params.get('smart_list_id'));

                // Find the config in the lists we just loaded
                const targetList = this.smartLists.find(l => l.id === id);
                if (targetList) {
                    // This function restores the FULL complex state (rules, sort, match mode)
                    this.applySearch(targetList);
                    return; // Stop here, applySearch handles the execution
                }
            }

            // Strategy B: Standard "Unpacked" URL (Tag Chips, Authors, etc.)
            // 1. Handle Sorting overrides
            if (params.has('sort_by')) {
                this.sortBy = params.get('sort_by');
                // Optional: Handle sort order if you passed it (e.g. &sort_order=asc)
                // We default to 'desc' in the model, but you could read it here if needed.
                shouldSearch = true;
            }

            if (params.has('sort_order')) {
                // You might need to add `sortOrder` to your Alpine data object if it isn't there,
                // or just pass it directly to the API payload if UI doesn't have a toggle for it.
                // The current UI relies on hardcoded 'desc' in performSearch or API defaults.
                this.sortOrder = params.get('sort_order');
            }

            // 2. Handle Filters (Deep Linking)
            // Allow search if 'field' exists AND ('value' OR 'operator' exists)
            // This supports ?field=summary&operator=is_empty
            if (params.has('field') && (params.has('value') || params.has('operator'))) {
                const field = params.get('field');
                const value = params.get('value');
                // Default to 'contains' if not specified
                const operator = params.get('operator') || 'contains';

                // Overwrite the default rule with the URL rule
                this.rules = [{
                    id: 1,
                    field: field,
                    operator: operator,
                    // Check if value exists before wrapping in array.
                    // If null, return empty array [] which TagInput can handle.
                    value: value ? [value] : []

                }];

                shouldSearch = true;
            }

            // Capture Library Context
            if (params.has('library_id')) {

                this.contextLibraryId = parseInt(params.get('library_id'));

                // Optional: Fetch the name for the UI
                this.fetchLibraryName(this.contextLibraryId);
                shouldSearch = true;
            }

            // 3. Trigger Search if any params were found
            // Use $nextTick to ensure the DOM/Alpine data is ready
            if (shouldSearch) {
                this.$nextTick(() => {
                    this.performSearch();
                });
            }
        },

        addRule() {
            this.rules.push({ id: this.nextId++, field: 'character', operator: 'contains', value: [] });
        },

        removeRule(index) {
            // Don't remove the last rule, just reset it
            if (this.rules.length === 1) {
                this.rules[0].value = [];
                return;
            }
            this.rules.splice(index, 1);
        },

        resetRule(rule) {
            rule.value = []; // Clear values when field changes
        },

        async performSearch() {
            this.loading = true;
            this.hasSearched = true;
            this.results = []; // Clear previous results while loading

            const payload = this.buildSearchPayload();
            console.log("payload", payload);

            try {
                const res = await fetch(window.url('/api/comics/search'), {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify(payload)
                });

                if (!res.ok) throw new Error("Search failed");

                const data = await res.json();
                this.results = data.results;
                this.totalResults = data.total;
            } catch(e) {
                console.error("Search failed", e);
            } finally {
                this.loading = false;
            }
        },

        async loadSavedList() {
            try {

                const [savedRes, smartRes] = await Promise.all([
                    fetch(window.url('/api/saved-searches/')),
                    fetch(window.url('/api/smart-lists/'))
                ]);

                if (savedRes.ok) this.savedSearches = await savedRes.json();
                if (smartRes.ok) {
                    const rawSmartLists = await smartRes.json();

                    // Normalize them to match Saved Search structure for easier handling
                    this.smartLists = rawSmartLists.map(list => ({
                        id: list.id,
                        name: list.name,
                        icon: list.icon,
                        query: list.query,
                        isSmart: true
                    }));
                }

            } catch(e) { console.error(e); }
        },

        openSaveModal() {
            this.saveModalOpen = true;
        },

         async saveSearch() {
            if (!this.newSearchName.trim()) return;

            const payload = {
                name: this.newSearchName,
                query: this.buildSearchPayload()
            };

            try {
                const res = await fetch(window.url('/api/saved-searches/'), {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify(payload)
                });

                if (res.ok) {
                    this.saveModalOpen = false;
                    this.newSearchName = '';
                    this.loadedListId = null;
                    await this.loadSavedList();
                    window.comicServer.showToast("Search configuration saved!", "success");
                }
            } catch(e) { console.error(e); }
        },

        async deleteSearch(id) {
            if(!confirm("Delete this saved search?")) return;
            await fetch(window.url(`/api/saved-searches/${id}`), { method: 'DELETE' });
            await this.loadSavedList(); // Refresh list
            window.comicServer.showToast("Saved Search deleted", "success");
        },

        applySearch(item) {

            this.loadedListId = item.id;

            // Restore State from JSON
            const q = item.query;

            this.match = q.match || 'all';
            this.sortBy = q.sort_by || 'created';
            this.sortOrder = q.sort_order || 'desc';
            this.limit = q.limit || 50;

            // Restore Rules (Deep copy to avoid reference issues)
            // Note: q.filters might be empty, handle that
            if (q.filters && q.filters.length > 0) {
                this.rules = q.filters.map((f, i) => ({
                    id: Date.now() + i + Math.random(),
                    field: f.field,
                    operator: f.operator,
                    value: f.value
                }));
            } else {
                this.rules = [{ id: Date.now() + 1 + Math.random(), field: 'series', operator: 'contains', value: [] }];
            }

            // Auto Run
            this.$nextTick(() => {
                this.performSearch();
                // Set the name input to match what we loaded,
                // making it easier to re-save/update
                this.newSearchName = item.name;
            });
        },

        // Helper to extract payload logic from performSearch
        buildSearchPayload() {
            return {
                match: this.match,
                filters: this.rules.map(r => ({
                    field: r.field,
                    operator: r.operator,
                    // If the user typed nothing in a text box, send null to be safe,
                    // but for tags (arrays), send the array.
                    value: (Array.isArray(r.value) && r.value.length === 0) ? null : r.value
                })).filter(r => {

                    // ALWAYS KEEP: Operators that don't need values
                    if (['is_empty', 'is_not_empty'].includes(r.operator)) return true;

                    // REMOVE: Null or Undefined
                    if (r.value === null || r.value === undefined) return false;

                    // REMOVE: Empty Strings
                    if (typeof r.value === 'string' && r.value.trim() === '') return false;

                    // REMOVE: Empty Arrays (Tags)
                    if (Array.isArray(r.value) && r.value.length === 0) return false;

                    return true;
                }),
                sort_by: this.sortBy,
                sort_order: this.sortOrder,
                limit: parseInt(this.limit),
                context_library_id: this.contextLibraryId
            };
        },

        async saveAsSmartList() {

            if (!this.newSearchName.trim()) {
                alert("Please enter a name first.");
                return;
            }

            // Reuse the payload builder so the logic matches exactly
            const payload = {
                name: this.newSearchName,
                query: this.buildSearchPayload()
            };

            try {

                if(this.loadedListId === null) {
                    // Create
                    const res = await fetch(window.url('/api/smart-lists/'), {
                        method: 'POST',
                        headers: {'Content-Type': 'application/json'},
                        body: JSON.stringify(payload)
                    });

                    if (res.ok) {
                        this.saveModalOpen = false;
                        window.comicServer.showToast("Smart List created!", "success");
                        this.newSearchName = '';
                    } else {
                        window.comicServer.showToast("Failed to create list.", "error");
                    }

                } else {
                    // Update
                    const res = await fetch(window.url(`/api/smart-lists/${this.loadedListId}`), {
                        method: 'PATCH',
                        headers: {'Content-Type': 'application/json'},
                        body: JSON.stringify(payload)
                    });

                    if (res.ok) {
                        this.saveModalOpen = false;
                        window.comicServer.showToast("Smart List updated!", "success");
                    } else {
                        window.comicServer.showToast("Failed to update list.", "error");
                    }
                }
            } catch(e) {
                console.error(e);
                window.comicServer.showToast("Network error.", "error");
            }
        },

        // Helper to get name (Optional polish)
        async fetchLibraryName(id) {
            try {
                const res = await fetch(window.url(`/api/libraries/${id}`));
                if(res.ok) {
                    const lib = await res.json();
                    this.contextLibraryName = lib.name;
                }
            } catch(e) {}
        },


    }));
});
</script>
{% endblock %}