{% extends "base.html" %}

{% block title %}Advanced Search - Comic Server{% endblock %}

{% block content %}
<div class="max-w-6xl mx-auto" x-data="searchBuilder()">

    <div class="flex justify-between items-center mb-6">
        <h1 class="text-3xl font-bold text-white">Advanced Search</h1>

        <div class="flex space-x-3" x-data="{ showLoadMenu: false }">
            <div class="relative">
                <button
                    x-on:click="showLoadMenu = !showLoadMenu; if(showLoadMenu) loadSavedList()"
                    x-on:click.away="showLoadMenu = false"
                    class="px-4 py-2 bg-gray-700 hover:bg-gray-600 text-gray-200 rounded-lg flex items-center gap-2 transition-colors"
                >
                    <span>ðŸ“‚ Load</span>
                    <span class="text-xs">â–¼</span>
                </button>

                <div
                    x-show="showLoadMenu"
                    class="absolute right-0 mt-2 w-64 bg-gray-800 border border-gray-600 rounded-lg shadow-xl z-50 overflow-hidden"
                    style="display: none;"
                    x-transition
                >
                    <div x-show="savedSearches.length === 0" class="p-4 text-gray-500 text-sm text-center">No saved searches.</div>

                    <template x-for="search in savedSearches" :key="search.id">
                        <div class="flex items-center justify-between p-2 hover:bg-gray-700 border-b border-gray-700/50 last:border-0 group">
                            <button
                                x-on:click="applySearch(search); showLoadMenu = false"
                                class="flex-1 text-left text-sm text-blue-300 hover:text-white truncate px-2"
                                x-text="search.name"
                            ></button>
                            <button
                                x-on:click.stop="deleteSearch(search.id)"
                                class="text-gray-600 hover:text-red-400 px-2 opacity-0 group-hover:opacity-100 transition-opacity"
                            >âœ•</button>
                        </div>
                    </template>
                </div>
            </div>

            <button
                x-on:click="openSaveModal()"
                class="px-4 py-2 bg-blue-600 hover:bg-blue-500 text-white rounded-lg flex items-center gap-2 transition-colors"
            >
                <span>ðŸ’¾ Save</span>
            </button>
        </div>
    </div>

    <div class="bg-gray-800 rounded-xl p-6 border border-gray-700 shadow-xl">

        <div class="flex items-center space-x-4 mb-6 border-b border-gray-700 pb-4">
            <span class="text-gray-400">Match</span>
            <select x-model="match" class="bg-gray-700 text-white rounded px-3 py-1 border border-gray-600 focus:ring-2 focus:ring-blue-500 outline-none">
                <option value="all">All Rules (AND)</option>
                <option value="any">Any Rule (OR)</option>
            </select>
            <span class="text-gray-400">of the following:</span>
        </div>

        <div class="space-y-4">
            <template x-for="(rule, index) in rules" :key="rule.id">
                <div class="flex flex-col md:flex-row gap-3 items-start md:items-center bg-gray-900/50 p-3 rounded-lg border border-gray-700/50">

                    <select x-model="rule.field" x-on:change="resetRule(rule)" class="w-full md:w-48 bg-gray-700 text-white rounded px-3 py-2 border border-gray-600 outline-none">
                        <optgroup label="Metadata">
                            <option value="series">Series Name</option>
                            <option value="title">Issue Title</option>
                            <option value="publisher">Publisher</option>
                            <option value="year">Release Year</option>
                            <option value="format">Format</option>
                            <option value="imprint">Imprint</option>
                        </optgroup>
                        <optgroup label="Creators">
                            <option value="writer">Writer</option>
                            <option value="penciller">Penciller</option>
                            <option value="inker">Inker</option>
                            <option value="colorist">Colorist</option>
                            <option value="editor">Editor</option>
                        </optgroup>
                        <optgroup label="Tags">
                            <option value="character">Character</option>
                            <option value="team">Team</option>
                            <option value="location">Location</option>
                            <option value="genre">Genre</option>
                        </optgroup>
                        <optgroup label="Organization">
                            <option value="library">Library</option>
                            <option value="collection">Collection</option>
                            <option value="reading_list">Reading List</option>
                            <option value="pull_list">Pull List</option>
                        </optgroup>
                    </select>

                    <select x-model="rule.operator" class="w-full md:w-40 bg-gray-700 text-white rounded px-3 py-2 border border-gray-600 outline-none">
                        <option value="equal">Equals</option>
                        <option value="not_equal">Not Equals</option>
                        <option value="contains">Contains (Any)</option>
                        <option value="does_not_contain">Does Not Contain</option>
                        <option value="must_contain">Must Contain (All)</option>
                        <option value="is_empty">Is Empty</option>
                        <option value="is_not_empty">Is Not Empty</option>
                    </select>

                    <div class="flex-1 w-full" x-show="!['is_empty', 'is_not_empty'].includes(rule.operator)">

                        <div x-show="['title', 'year'].includes(rule.field)">
                            <input type="text" x-model="rule.value" class="w-full bg-gray-700 text-white rounded px-3 py-2 border border-gray-600 outline-none focus:border-blue-500">
                        </div>

                        <div x-show="!['title', 'year'].includes(rule.field)">
                            <div
                                x-data="tagInput(rule)"
                                class="relative w-full"
                            >
                                <div class="bg-gray-700 border border-gray-600 rounded p-1 flex flex-wrap gap-2 min-h-[42px]">
                                    <template x-for="(tag, i) in tags" :key="i">
                                        <span class="bg-blue-600 text-white text-sm px-2 py-0.5 rounded flex items-center">
                                            <span x-text="tag"></span>
                                            <button x-on:click="removeTag(i)" class="ml-1 hover:text-red-300 font-bold">Ã—</button>
                                        </span>
                                    </template>

                                    <input
                                        type="text"
                                        x-model="input"
                                        @input.debounce.300ms="fetchSuggestions()"
                                        @keydown.enter.prevent="addTag()"
                                        @keydown.backspace="handleBackspace()"
                                        class="bg-transparent border-none focus:ring-0 text-white flex-1 min-w-[120px] outline-none h-8 px-1"
                                        placeholder="Type to find..."
                                    >
                                </div>

                                <div x-show="suggestions.length > 0" x-on:click.away="suggestions = []" class="absolute z-10 w-full bg-gray-700 border border-gray-600 rounded mt-1 shadow-lg max-h-60 overflow-y-auto">
                                    <template x-for="sugg in suggestions" :key="sugg">
                                        <div
                                            x-on:click="selectSuggestion(sugg)"
                                            class="px-3 py-2 hover:bg-blue-600 cursor-pointer text-white border-b border-gray-600 last:border-0"
                                            x-text="sugg"
                                        ></div>
                                    </template>
                                </div>
                            </div>
                        </div>

                    </div>

                    <button x-on:click="removeRule(index)" class="text-red-400 hover:text-red-300 p-2 hover:bg-red-900/30 rounded" title="Remove Rule">
                        âœ•
                    </button>
                </div>
            </template>
        </div>

        <div class="mt-4">
            <button x-on:click="addRule()" class="text-blue-400 hover:text-blue-300 font-bold flex items-center px-3 py-2 hover:bg-gray-700 rounded transition-colors">
                <span class="text-xl mr-2">+</span> Add Rule
            </button>
        </div>

        <div class="border-t border-gray-700 my-6"></div>

        <div class="flex flex-col md:flex-row justify-between items-center gap-4">
            <div class="flex items-center space-x-6">
                <div class="flex items-center space-x-2">
                    <span class="text-gray-400 text-sm">Sort By</span>
                    <select x-model="sortBy" class="bg-gray-700 text-white rounded px-2 py-1 text-sm border border-gray-600 outline-none">
                        <option value="created">Date Added</option>
                        <option value="updated">Date Updated</option>
                        <option value="year">Release Year</option>
                        <option value="series">Series Name</option>
                        <option value="title">Issue Title</option>
                        <option value="page_count">Page Count</option>
                    </select>
                </div>
                <div class="flex items-center space-x-2">
                    <span class="text-gray-400 text-sm">Limit</span>
                    <input type="number" x-model="limit" class="w-20 bg-gray-700 text-white rounded px-2 py-1 text-sm border border-gray-600 outline-none text-center">
                </div>
            </div>

            <button x-on:click="performSearch()" class="w-full md:w-auto bg-blue-600 hover:bg-blue-500 text-white font-bold py-2 px-8 rounded-lg shadow-lg flex items-center justify-center gap-2 transition-colors">
                <span x-show="loading" class="animate-spin">â†»</span>
                <span>Search Comics</span>
            </button>
        </div>
    </div>

    <div class="mt-8" x-show="hasSearched" style="display: none;">
        <h2 class="text-xl font-bold mb-4 flex items-center text-white">
            Results
            <span class="ml-3 text-sm font-normal text-gray-300 bg-gray-800 px-3 py-1 rounded-full border border-gray-700" x-text="`${totalResults} found`"></span>
        </h2>

        <div class="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-6 gap-4">
             <template x-for="comic in results" :key="comic.id">
                {% include "partials/comic_card.html" %}
             </template>
        </div>

        <div x-show="!loading && results.length === 0" class="text-center py-20 bg-gray-800/50 rounded-xl border border-dashed border-gray-700">
            <p class="text-gray-400 text-lg">No comics found matching your criteria.</p>
            <button x-on:click="rules=[{id:1, field:'series', operator:'contains', value:[]}]" class="mt-4 text-blue-400 hover:underline">Reset Filters</button>
        </div>
    </div>


<div x-show="saveModalOpen" class="fixed inset-0 bg-black/80 flex items-center justify-center z-50" style="display: none;" x-transition.opacity>
    <div class="bg-gray-800 p-6 rounded-lg w-full max-w-sm border border-gray-700 shadow-2xl" x-on:click.away="saveModalOpen = false">
        <h3 class="text-xl font-bold mb-4 text-white">Save Search Configuration</h3>
        <input
            type="text"
            x-model="newSearchName"
            placeholder="e.g. 'Alan Moore 80s'"
            class="w-full bg-gray-900 border border-gray-700 rounded px-3 py-2 text-white focus:border-blue-500 outline-none mb-4"
            @keydown.enter="saveSearch()"
        >
        <div class="flex justify-end gap-2">
            <button x-on:click="saveModalOpen = false" class="text-gray-400 hover:text-white px-4 py-2">Cancel</button>
            <button x-on:click="saveSearch()" class="bg-blue-600 hover:bg-blue-500 text-white px-4 py-2 rounded">Save</button>
        </div>
    </div>
</div>

</div>



<script>
document.addEventListener('alpine:init', () => {

    // 1. Tag Input Component (Reusable for each row)
    Alpine.data('tagInput', (rule) => ({
        input: '',
        tags: [], // Local array to hold badges
        suggestions: [],

        init() {

            // 1. Initial Population
            this.syncTagsFromRule();

            // 2. Watch for changes from parent (e.g. loading saved search)
            // We pass a function to $watch to observe the external 'rule' object
            this.$watch(() => rule.value, (newValue) => {
                this.syncTagsFromRule();
            });

            // If rule has value loaded from save, populate tags
            // Ensure we handle both single value (string/int) and array
            //if (rule.value) {
                //this.tags = Array.isArray(rule.value) ? rule.value : [rule.value];
            //}
        },

        syncTagsFromRule() {
                            console.log("fired watch");
            if (rule.value) {
                const newTags = Array.isArray(rule.value) ? rule.value : [rule.value];

                // Only update if different to avoid feedback loops
                // (Simple stringify check is sufficient for string arrays)
                if (JSON.stringify(newTags) !== JSON.stringify(this.tags)) {
                    this.tags = [...newTags]; // Create a copy
                }
            } else {
                this.tags = [];
            }
        },

        async fetchSuggestions() {
            if (this.input.length < 2) {
                this.suggestions = [];
                return;
            }
            try {
                // Call our API
                const res = await fetch(`/api/search/suggestions?field=${rule.field}&query=${this.input}`);
                this.suggestions = await res.json();
            } catch(e) { console.error(e); }
        },

        addTag() {
            if (this.input.trim()) {
                this.tags.push(this.input.trim());
                this.updateRuleValue();
                this.input = '';
                this.suggestions = [];
            }
        },

        selectSuggestion(val) {
            this.tags.push(val);
            this.updateRuleValue();
            this.input = '';
            this.suggestions = [];
        },

        removeTag(index) {
            this.tags.splice(index, 1);
            this.updateRuleValue();
        },

        handleBackspace() {
            if (this.input === '' && this.tags.length > 0) {
                this.tags.pop();
                this.updateRuleValue();
            }
        },

        updateRuleValue() {
            // Update the parent rule object
            // We use a spread copy to ensure reactivity triggers if needed
            rule.value = [...this.tags];
            //rule.value = this.tags;
        }
    }));

    // 2. Main Search Builder Logic
    Alpine.data('searchBuilder', () => ({
        rules: [
            { id: 1, field: 'series', operator: 'contains', value: [] }
        ],
        match: 'all',
        limit: 50,
        sortBy: 'created',
        sortOrder: 'desc',
        results: [],
        totalResults: 0,
        loading: false,
        hasSearched: false,
        nextId: 2,

        savedSearches: [],
        saveModalOpen: false,
        newSearchName: '',

        init() {
            this.checkUrlParams();
            this.loadSavedList();
        },

        checkUrlParams() {
            const params = new URLSearchParams(window.location.search);
            let shouldSearch = false;

            // 1. Handle Sorting overrides
            if (params.has('sort_by')) {
                this.sortBy = params.get('sort_by');
                // Optional: Handle sort order if you passed it (e.g. &sort_order=asc)
                // We default to 'desc' in the model, but you could read it here if needed.
                shouldSearch = true;
            }

            if (params.has('sort_order')) {
                // You might need to add `sortOrder` to your Alpine data object if it isn't there,
                // or just pass it directly to the API payload if UI doesn't have a toggle for it.
                // The current UI relies on hardcoded 'desc' in performSearch or API defaults.
                this.sortOrder = params.get('sort_order');
            }

            // 2. Handle Filters (Deep Linking)
            if (params.has('field') && params.has('value')) {
                const field = params.get('field');
                const value = params.get('value');
                // Default to 'contains' if not specified
                const operator = params.get('operator') || 'contains';

                // Overwrite the default rule with the URL rule
                this.rules = [{
                    id: 1,
                    field: field,
                    operator: operator,
                    // TagInput expects an array
                    value: [value]
                }];

                shouldSearch = true;
            }

            // 3. Trigger Search if any params were found
            // Use $nextTick to ensure the DOM/Alpine data is ready
            if (shouldSearch) {
                this.$nextTick(() => {
                    this.performSearch();
                });
            }
        },

        addRule() {
            this.rules.push({ id: this.nextId++, field: 'character', operator: 'contains', value: [] });
        },

        removeRule(index) {
            // Don't remove the last rule, just reset it
            if (this.rules.length === 1) {
                this.rules[0].value = [];
                return;
            }
            this.rules.splice(index, 1);
        },

        resetRule(rule) {
            rule.value = []; // Clear values when field changes
        },

        async performSearch() {
            this.loading = true;
            this.hasSearched = true;
            this.results = []; // Clear previous results while loading

            // Prepare payload
            /*
            const payload = {
                match: this.match,
                filters: this.rules.map(r => ({
                    field: r.field,
                    operator: r.operator,
                    // If the user typed nothing in a text box, send null to be safe,
                    // but for tags (arrays), send the array.
                    value: (Array.isArray(r.value) && r.value.length === 0) ? null : r.value
                })).filter(r => r.operator === 'is_empty' || r.operator === 'is_not_empty' || r.value !== null), // Filter out incomplete rules

                sort_by: this.sortBy,
                sort_order: this.sortOrder,
                limit: parseInt(this.limit)
            };
            */

            const payload = this.buildSearchPayload();

            try {
                const res = await fetch('/api/comics/search', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify(payload)
                });

                if (!res.ok) throw new Error("Search failed");

                const data = await res.json();
                this.results = data.results;
                this.totalResults = data.total;
            } catch(e) {
                console.error("Search failed", e);
            } finally {
                this.loading = false;
            }
        },

        async loadSavedList() {
            try {
                const res = await fetch('/api/saved-searches/');
                if (res.ok) this.savedSearches = await res.json();
            } catch(e) { console.error(e); }
        },

        openSaveModal() {
            this.newSearchName = '';
            this.saveModalOpen = true;
        },

         async saveSearch() {
            if (!this.newSearchName.trim()) return;

            const payload = {
                name: this.newSearchName,
                query: this.buildSearchPayload() // Refactor performSearch to use this helper
            };

            try {
                const res = await fetch('/api/saved-searches/', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify(payload)
                });

                if (res.ok) {
                    this.saveModalOpen = false;
                    alert("Search saved!");
                }
            } catch(e) { console.error(e); }
        },

        async deleteSearch(id) {
            if(!confirm("Delete this saved search?")) return;
            await fetch(`/api/saved-searches/${id}`, { method: 'DELETE' });
            this.loadSavedList(); // Refresh list
        },

        applySearch(saved) {
            // Restore State from JSON
            const q = saved.query;
            this.match = q.match;
            this.sortBy = q.sort_by;
            this.sortOrder = q.sort_order;
            this.limit = q.limit;

            // Restore Rules (Deep copy to avoid reference issues)
            // Note: q.filters might be empty, handle that
            if (q.filters && q.filters.length > 0) {
                this.rules = q.filters.map((f, i) => ({
                    id: Date.now() + i + Math.random(),
                    field: f.field,
                    operator: f.operator,
                    value: f.value
                }));
            } else {
                this.rules = [{ id: Date.now() + 1 + Math.random(), field: 'series', operator: 'contains', value: [] }];
            }

            // Auto Run
            this.$nextTick(() => {
                this.performSearch();
            });
        },

        // Helper to extract payload logic from performSearch
        buildSearchPayload() {
            return {
                match: this.match,
                filters: this.rules.map(r => ({
                    field: r.field,
                    operator: r.operator,
                    // If the user typed nothing in a text box, send null to be safe,
                    // but for tags (arrays), send the array.
                    value: (Array.isArray(r.value) && r.value.length === 0) ? null : r.value
                })).filter(r => r.operator === 'is_empty' || r.operator === 'is_not_empty' || r.value !== null), // Filter out incomplete rules
                sort_by: this.sortBy,
                sort_order: this.sortOrder,
                limit: parseInt(this.limit)
            };
        },


    }));
});
</script>
{% endblock %}